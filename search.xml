<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>GDB 全指令速查大全（for Linux x86_64 C/C++ demo_multithread）</title>
    <url>/gdb%E5%85%A8%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>✅ <strong>Cheat Sheet 完整覆盖绝大部分 GDB 实操语法、表达式、断点&#x2F;变量&#x2F;进程&#x2F;线程&#x2F;内存  操作等，足够作为日常 Linux x86_64 C&#x2F;C++ 调试的全功能清单与速查表。</strong></p>
<span id="more"></span>

<hr>
<h2 id="📘-目录"><a href="#📘-目录" class="headerlink" title="📘 目录"></a>📘 目录</h2><ol>
<li>基本启动与退出  </li>
<li>运行控制与进程管理  </li>
<li>断点种类与高级断点  </li>
<li>单步与继续执行  </li>
<li>线程与进程调试  </li>
<li>变量与表达式  </li>
<li>内存读写与堆栈窥探  </li>
<li>寄存器与上下文  </li>
<li>汇编与反汇编  </li>
<li>watchpoint &#x2F; 硬件断点  </li>
<li>函数与调用栈  </li>
<li>日志输出与格式化打印  </li>
<li>脚本化与命令别名  </li>
<li>TUI 交互模式  </li>
<li>远程调试与 gdbserver  </li>
<li>core dump 分析  </li>
<li>GDB Python 简单示例  </li>
<li>常用 alias 与 快捷组合  </li>
<li>高危命令小心清单  </li>
<li>学习与心法附注</li>
</ol>
<p>每条指令：<br><code>语法</code> + <code>示例</code> + <code>说明</code> + <code>停顿/风险</code>。</p>
<hr>
<h2 id="一、启动与退出"><a href="#一、启动与退出" class="headerlink" title="一、启动与退出"></a>一、启动与退出</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
<th>停顿风险</th>
</tr>
</thead>
<tbody><tr>
<td><code>gdb &lt;prog&gt;</code></td>
<td><code>gdb ./demo_multithread</code></td>
<td>启动调试</td>
<td>无</td>
</tr>
<tr>
<td><code>gdb --args &lt;prog&gt; &lt;arg...&gt;</code></td>
<td><code>gdb --args ./demo_multithread -t 4</code></td>
<td>可带参数启动</td>
<td>无</td>
</tr>
<tr>
<td><code>attach &lt;pid&gt;</code></td>
<td><code>attach 12345</code></td>
<td>附加到已运行进程</td>
<td>中</td>
</tr>
<tr>
<td><code>detach</code></td>
<td>—</td>
<td>从进程分离</td>
<td>无</td>
</tr>
<tr>
<td><code>quit</code></td>
<td>—</td>
<td>退出 GDB</td>
<td>无</td>
</tr>
</tbody></table>
<hr>
<h2 id="二、运行控制与进程管理"><a href="#二、运行控制与进程管理" class="headerlink" title="二、运行控制与进程管理"></a>二、运行控制与进程管理</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>run [args]</code></td>
<td><code>run 10 foo.txt</code></td>
<td>启动程序</td>
</tr>
<tr>
<td><code>start</code></td>
<td>—</td>
<td>启动并在 main 前暂停</td>
</tr>
<tr>
<td><code>continue</code> &#x2F; <code>c</code></td>
<td>—</td>
<td>继续运行</td>
</tr>
<tr>
<td><code>kill</code></td>
<td>—</td>
<td>停止被调试进程</td>
</tr>
<tr>
<td><code>signal &lt;sig&gt;</code></td>
<td><code>signal SIGUSR1</code></td>
<td>向程序发送信号</td>
</tr>
<tr>
<td><code>set args</code></td>
<td><code>set args input1 input2</code></td>
<td>设置运行参数</td>
</tr>
<tr>
<td><code>show args</code></td>
<td>—</td>
<td>查看参数</td>
</tr>
<tr>
<td>&#96;set follow-fork-mode [child</td>
<td>parent]&#96;</td>
<td><code>set follow-fork-mode child</code></td>
</tr>
<tr>
<td><code>catch fork/vfork/exec/catch throw/catch catch</code></td>
<td>—</td>
<td>捕获事件</td>
</tr>
<tr>
<td><code>info inferiors</code></td>
<td>—</td>
<td>多进程（inferior）信息</td>
</tr>
<tr>
<td><code>inferior N</code></td>
<td><code>inferior 2</code></td>
<td>切换到第 N 个进程</td>
</tr>
</tbody></table>
<hr>
<h2 id="三、断点系统详解"><a href="#三、断点系统详解" class="headerlink" title="三、断点系统详解"></a>三、断点系统详解</h2><table>
<thead>
<tr>
<th>类型</th>
<th>语法</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>文件行</td>
<td><code>break file:line</code></td>
<td><code>break main.cpp:42</code></td>
<td>代码行断点</td>
</tr>
<tr>
<td>函数</td>
<td><code>break &lt;func&gt;</code></td>
<td><code>break worker_thread</code></td>
<td>函数入口</td>
</tr>
<tr>
<td>地址</td>
<td><code>break *addr</code></td>
<td><code>break *0x401000</code></td>
<td>指令地址</td>
</tr>
<tr>
<td>临时</td>
<td><code>tbreak</code></td>
<td><code>tbreak foo</code></td>
<td>一次性断点</td>
</tr>
<tr>
<td>条件</td>
<td><code>break &lt;func&gt; if &lt;expr&gt;</code></td>
<td><code>break update if count&gt;100</code></td>
<td>条件命中</td>
</tr>
<tr>
<td>忽略次数</td>
<td><code>ignore &lt;bp_no&gt; &lt;N&gt;</code></td>
<td><code>ignore 1 5</code></td>
<td>忽略前 5 次</td>
</tr>
<tr>
<td>watch</td>
<td><code>watch expr</code></td>
<td><code>watch var</code></td>
<td>写监视点</td>
</tr>
<tr>
<td>rwatch</td>
<td><code>rwatch expr</code></td>
<td><code>rwatch counter</code></td>
<td>读监视点</td>
</tr>
<tr>
<td>awatch</td>
<td><code>awatch expr</code></td>
<td><code>awatch *ptr</code></td>
<td>读写监视</td>
</tr>
<tr>
<td>hardware bp</td>
<td><code>hbreak</code></td>
<td><code>hbreak *0x401200</code></td>
<td>硬件断点</td>
</tr>
<tr>
<td>disable</td>
<td><code>disable &lt;bp_no&gt;</code></td>
<td>—</td>
<td>禁用断点</td>
</tr>
<tr>
<td>enable</td>
<td><code>enable &lt;bp_no&gt;</code></td>
<td>—</td>
<td>启用断点</td>
</tr>
<tr>
<td>delete</td>
<td><code>delete &lt;bp_no&gt;</code></td>
<td>—</td>
<td>删除断点</td>
</tr>
<tr>
<td>info break</td>
<td>—</td>
<td>查看断点表</td>
<td></td>
</tr>
<tr>
<td>commands + end</td>
<td>如下</td>
<td>命中执行命令块</td>
<td></td>
</tr>
<tr>
<td>break thread-specific</td>
<td><code>break func thread 3</code></td>
<td>仅某线程命中</td>
<td></td>
</tr>
</tbody></table>
<p>命令块示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break process_request if id==42</span><br><span class="line">commands</span><br><span class="line">  silent</span><br><span class="line">  printf &quot;hit id=42 at %p\n&quot;,$rip</span><br><span class="line">  continue</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<blockquote>
<p>⚠️ 高风险：命令块内若 <code>continue</code>，会忽略用户交互。</p>
</blockquote>
<hr>
<h2 id="四、单步与继续"><a href="#四、单步与继续" class="headerlink" title="四、单步与继续"></a>四、单步与继续</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>step</code> &#x2F; <code>s</code></td>
<td>—</td>
<td>单步（进入子函数）</td>
</tr>
<tr>
<td><code>next</code> &#x2F; <code>n</code></td>
<td>—</td>
<td>单步（不进入）</td>
</tr>
<tr>
<td><code>finish</code></td>
<td>—</td>
<td>运行至当前函数返回</td>
</tr>
<tr>
<td><code>until [loc]</code></td>
<td><code>until 100</code></td>
<td>运行到指定行</td>
</tr>
<tr>
<td><code>advance &lt;loc&gt;</code></td>
<td><code>advance update</code></td>
<td>快进到函数入口</td>
</tr>
<tr>
<td><code>jump &lt;loc&gt;</code></td>
<td><code>jump main.cpp:88</code></td>
<td>强制跳转执行位置</td>
</tr>
<tr>
<td><code>set scheduler-locking on</code></td>
<td>—</td>
<td>单线程执行锁</td>
</tr>
</tbody></table>
<hr>
<h2 id="五、多线程调试"><a href="#五、多线程调试" class="headerlink" title="五、多线程调试"></a>五、多线程调试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info threads                  # 列出线程 (TID, 状态)</span><br><span class="line">thread &lt;N&gt;                    # 切换到线程 N</span><br><span class="line">thread apply all bt           # 全线程回溯</span><br><span class="line">thread apply all bt full      # 全栈详细信息</span><br><span class="line">thread apply 2 4 info locals  # 对特定线程执行命令</span><br><span class="line">set scheduler-locking step    # 单步时仅当前线程执行</span><br></pre></td></tr></table></figure>

<p>在多线程程序中也可使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">break func thread 5 if value==1</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="六、变量与表达式"><a href="#六、变量与表达式" class="headerlink" title="六、变量与表达式"></a>六、变量与表达式</h2><table>
<thead>
<tr>
<th>功能</th>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>打印变量</td>
<td><code>print expr</code></td>
<td><code>print count</code></td>
<td>显示变量值</td>
</tr>
<tr>
<td>简写</td>
<td><code>p</code></td>
<td><code>p i</code></td>
<td>快速显示</td>
</tr>
<tr>
<td>修改变量</td>
<td><code>set var &lt;name&gt;=&lt;value&gt;</code></td>
<td><code>set var flag=1</code></td>
<td>修改运行时变量</td>
</tr>
<tr>
<td>监视变量变化</td>
<td><code>display expr</code></td>
<td><code>display x*y</code></td>
<td>每步显示</td>
</tr>
<tr>
<td>停止显示</td>
<td><code>undisplay N</code></td>
<td>—</td>
<td>取消</td>
</tr>
<tr>
<td>临时定义变量</td>
<td><code>set $tmp=expr</code></td>
<td><code>set $tmp=$eax+4</code></td>
<td>自定义 GDB 内部变量</td>
</tr>
<tr>
<td>使用内部变量</td>
<td><code>$tmp</code></td>
<td><code>p $tmp</code></td>
<td>在表达式中复用计算值</td>
</tr>
<tr>
<td>info locals</td>
<td>—</td>
<td>当前函数局部变量</td>
<td></td>
</tr>
<tr>
<td>info args</td>
<td>—</td>
<td>当前函数参数</td>
<td></td>
</tr>
<tr>
<td>whatis var</td>
<td>—</td>
<td>获取类型声明</td>
<td></td>
</tr>
<tr>
<td>ptype var</td>
<td>—</td>
<td>打印详细类型信息</td>
<td></td>
</tr>
<tr>
<td>call func()</td>
<td><code>call compute_sum(3,5)</code></td>
<td>调用函数（可带副作用）</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ 若函数含锁&#x2F;IO&#x2F;状态依赖，<code>call</code> 可能修改程序行为。</p>
</blockquote>
<hr>
<h2 id="七、内存与栈操作"><a href="#七、内存与栈操作" class="headerlink" title="七、内存与栈操作"></a>七、内存与栈操作</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>x&#x2F;Nfu <expr></td>
<td><code>x/16xb buf</code></td>
<td>按格式查看内存</td>
</tr>
<tr>
<td>格式字符</td>
<td>x&#x3D;16进制、d&#x3D;十进制、s&#x3D;字符串、i&#x3D;指令</td>
<td></td>
</tr>
<tr>
<td>u&#x3D;单元字节</td>
<td>b(1), h(2), w(4), g(8)</td>
<td></td>
</tr>
<tr>
<td>x&#x2F;32gx $rsp</td>
<td>—</td>
<td>查看栈顶</td>
</tr>
<tr>
<td>set <em>(type</em>)addr &#x3D; value</td>
<td><code>set *(int*)0x7ffeef = 10</code></td>
<td>修改内存</td>
</tr>
<tr>
<td>find <start>,<end>,<pat></td>
<td><code>find 0x400000,0x410000,0x90</code></td>
<td>内存搜索</td>
</tr>
</tbody></table>
<hr>
<h2 id="八、寄存器与上下文"><a href="#八、寄存器与上下文" class="headerlink" title="八、寄存器与上下文"></a>八、寄存器与上下文</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">info registers</span><br><span class="line">info all-registers</span><br><span class="line">info float</span><br><span class="line">info vector</span><br><span class="line">set $rax = 0</span><br><span class="line">p $rip</span><br></pre></td></tr></table></figure>
<p>寄存器变量 <code>$rip</code>, <code>$rsp</code>, <code>$rbp</code>, <code>$rax</code>, <code>$rbx</code>, … 可直接在表达式中使用。</p>
<hr>
<h2 id="九、反汇编与执行流"><a href="#九、反汇编与执行流" class="headerlink" title="九、反汇编与执行流"></a>九、反汇编与执行流</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>&#96;disassemble [func</td>
<td>addr-range]&#96;</td>
<td><code>disassemble main</code></td>
</tr>
<tr>
<td><code>x/10i $pc</code></td>
<td>—</td>
<td>周边指令</td>
</tr>
<tr>
<td><code>layout asm</code></td>
<td>—</td>
<td>TUI 模式中汇编</td>
</tr>
<tr>
<td><code>si</code></td>
<td>—</td>
<td>单步汇编级</td>
</tr>
<tr>
<td><code>ni</code></td>
<td>—</td>
<td>不入子调用步进</td>
</tr>
<tr>
<td><code>info line *$rip</code></td>
<td>—</td>
<td>查看汇编对应源码</td>
</tr>
<tr>
<td><code>info frame</code></td>
<td>—</td>
<td>当前调用帧寄存器与栈边界</td>
</tr>
</tbody></table>
<hr>
<h2 id="十、watchpoints-与硬件监控"><a href="#十、watchpoints-与硬件监控" class="headerlink" title="十、watchpoints 与硬件监控"></a>十、watchpoints 与硬件监控</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>watch var</td>
<td><code>watch counter</code></td>
<td>写时断点</td>
</tr>
<tr>
<td>rwatch var</td>
<td><code>rwatch *ptr</code></td>
<td>读时断点</td>
</tr>
<tr>
<td>awatch var</td>
<td><code>awatch *p</code></td>
<td>读写断点</td>
</tr>
<tr>
<td>info watchpoints</td>
<td>—</td>
<td>查看当前 watch</td>
</tr>
<tr>
<td>delete watchpoints</td>
<td>—</td>
<td>清除所有 watch</td>
</tr>
<tr>
<td>hwatch expr</td>
<td><code>hwatch *addr</code></td>
<td>硬件 watch（部分平台）</td>
</tr>
<tr>
<td>cond watch</td>
<td><code>watch x if x&gt;100</code></td>
<td>条件触发</td>
</tr>
</tbody></table>
<blockquote>
<p>⚠️ x86 通常 4 个硬件断点资源限制。</p>
</blockquote>
<hr>
<h2 id="十一、函数与调用栈"><a href="#十一、函数与调用栈" class="headerlink" title="十一、函数与调用栈"></a>十一、函数与调用栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">backtrace / bt                # 调用栈</span><br><span class="line">bt full                       # 带局部变量</span><br><span class="line">frame &lt;N&gt;                     # 切换帧</span><br><span class="line">up / down                     # 上/下一个帧</span><br><span class="line">info args                     # 当前帧参数</span><br><span class="line">return &lt;expr&gt;                 # 提前从当前函数返回</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十二、输出与格式化"><a href="#十二、输出与格式化" class="headerlink" title="十二、输出与格式化"></a>十二、输出与格式化</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>printf “format”, vars</td>
<td><code>printf &quot;len=%d\n&quot;, len</code></td>
<td>自定义输出</td>
</tr>
<tr>
<td>set logging on&#x2F;off</td>
<td>—</td>
<td>输出重定向到 to <code>gdb.txt</code></td>
</tr>
<tr>
<td>set pagination off</td>
<td>—</td>
<td>输出全展开</td>
</tr>
<tr>
<td>shell <cmd></td>
<td><code>shell ls /tmp</code></td>
<td>执行外部命令</td>
</tr>
<tr>
<td>echo</td>
<td><code>echo Hello\n</code></td>
<td>控制台输出</td>
</tr>
</tbody></table>
<hr>
<h2 id="十三、脚本与别名"><a href="#十三、脚本与别名" class="headerlink" title="十三、脚本与别名"></a>十三、脚本与别名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">define btf</span><br><span class="line">  thread apply all bt full</span><br><span class="line">end</span><br><span class="line">alias btf = btf</span><br><span class="line"></span><br><span class="line">define ctx</span><br><span class="line">  info registers</span><br><span class="line">  info locals</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>可放入 <code>.gdbinit</code> 内。<br>执行外部脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &lt;file.gdb&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十四、TUI-模式"><a href="#十四、TUI-模式" class="headerlink" title="十四、TUI 模式"></a>十四、TUI 模式</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>layout src</code></td>
<td>源码窗口</td>
</tr>
<tr>
<td><code>layout asm</code></td>
<td>汇编窗口</td>
</tr>
<tr>
<td><code>layout regs</code></td>
<td>寄存器窗口</td>
</tr>
<tr>
<td><code>focus next/prev</code></td>
<td>切换焦点</td>
</tr>
<tr>
<td><code>refresh</code></td>
<td>重绘 TUI 界面</td>
</tr>
</tbody></table>
<p>在 CLI 模式中按 <code>Ctrl+X A</code> 可切换 TUI ↔ 普通模式。</p>
<hr>
<h2 id="十五、远程调试-gdbserver"><a href="#十五、远程调试-gdbserver" class="headerlink" title="十五、远程调试 (gdbserver)"></a>十五、远程调试 (gdbserver)</h2><p>目标机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdbserver :1234 ./demo_multithread</span><br></pre></td></tr></table></figure>
<p>本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gdb ./demo_multithread</span><br><span class="line">target remote &lt;ip&gt;:1234</span><br><span class="line"><span class="built_in">set</span> sysroot /usr/sysroot/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 若跨架构：用 <code>gdb-multiarch</code>。</p>
</blockquote>
<hr>
<h2 id="十六、Core-Dump-分析"><a href="#十六、Core-Dump-分析" class="headerlink" title="十六、Core Dump 分析"></a>十六、Core Dump 分析</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br><span class="line">./demo_multithread</span><br><span class="line"><span class="comment"># 崩溃后：</span></span><br><span class="line">gdb ./demo_multithread core</span><br><span class="line">(gdb) bt full</span><br><span class="line">(gdb) info sharedlibrary</span><br><span class="line">(gdb) info registers</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="十七、GDB-Python-基础"><a href="#十七、GDB-Python-基础" class="headerlink" title="十七、GDB Python 基础"></a>十七、GDB Python 基础</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> gdb</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hello</span>(gdb.Command):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">s</span>): <span class="built_in">super</span>().__init__(<span class="string">&quot;hello&quot;</span>, gdb.COMMAND_USER)</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">invoke</span>(<span class="params">s,arg,from_tty</span>): <span class="built_in">print</span>(<span class="string">&quot;Hello GDB!&quot;</span>)</span><br><span class="line">Hello()</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>→ 运行：<code>hello</code></p>
<hr>
<h2 id="十八、20-条高频可复制命令清单"><a href="#十八、20-条高频可复制命令清单" class="headerlink" title="十八、20 条高频可复制命令清单"></a>十八、20 条高频可复制命令清单</h2><table>
<thead>
<tr>
<th>序号</th>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><code>break main</code></td>
<td>在主函数设置断点</td>
</tr>
<tr>
<td>2</td>
<td><code>break foo if x&gt;5</code></td>
<td>条件断点</td>
</tr>
<tr>
<td>3</td>
<td><code>tbreak bar</code></td>
<td>单次断点</td>
</tr>
<tr>
<td>4</td>
<td><code>info break</code></td>
<td>查看所有断点</td>
</tr>
<tr>
<td>5</td>
<td><code>display var</code></td>
<td>每步显示变量</td>
</tr>
<tr>
<td>6</td>
<td><code>thread apply all bt full</code></td>
<td>所有线程栈</td>
</tr>
<tr>
<td>7</td>
<td><code>set scheduler-locking on</code></td>
<td>单线程锁步</td>
</tr>
<tr>
<td>8</td>
<td><code>watch *ptr</code></td>
<td>添加 watchpoint</td>
</tr>
<tr>
<td>9</td>
<td><code>info registers</code></td>
<td>查看寄存器</td>
</tr>
<tr>
<td>10</td>
<td><code>disassemble /m main</code></td>
<td>混合汇编源码</td>
</tr>
<tr>
<td>11</td>
<td><code>x/32gx $rsp</code></td>
<td>查看当前栈 256B</td>
</tr>
<tr>
<td>12</td>
<td><code>info locals</code></td>
<td>局部变量</td>
</tr>
<tr>
<td>13</td>
<td><code>call debug_dump()</code></td>
<td>调用自定义函数</td>
</tr>
<tr>
<td>14</td>
<td><code>layout src</code></td>
<td>打开源码视图</td>
</tr>
<tr>
<td>15</td>
<td><code>source script.gdb</code></td>
<td>加载脚本</td>
</tr>
<tr>
<td>16</td>
<td><code>set logging on</code></td>
<td>自动保存输出</td>
</tr>
<tr>
<td>17</td>
<td><code>attach 1234</code></td>
<td>附加调试</td>
</tr>
<tr>
<td>18</td>
<td><code>detach</code></td>
<td>分离目标</td>
</tr>
<tr>
<td>19</td>
<td><code>bt full</code></td>
<td>报错回溯</td>
</tr>
<tr>
<td>20</td>
<td><code>quit</code></td>
<td>退出调试器</td>
</tr>
</tbody></table>
<hr>
<h2 id="十九、高危命令注意"><a href="#十九、高危命令注意" class="headerlink" title="十九、高危命令注意"></a>十九、高危命令注意</h2><ul>
<li><code>jump</code> &#x2F; <code>set $rip</code> → 改变执行流，可能破坏堆栈  </li>
<li><code>call</code> → 调用目标代码可有副作用  </li>
<li><code>set var</code> → 修改关键逻辑需谨慎  </li>
<li><code>detach</code> → 会恢复执行，请确保安全  </li>
<li><code>signal</code> → 可能导致即时终止或异常</li>
</ul>
<hr>
<h2 id="二十、调试心法小结"><a href="#二十、调试心法小结" class="headerlink" title="二十、调试心法小结"></a>二十、调试心法小结</h2><ol>
<li><strong>所有命令皆为工具，不为表演</strong> —— 优先录制自动化。  </li>
<li><strong>先追条件，再断行为</strong> —— 用 <code>break if</code> 不要撒网。  </li>
<li><strong>多线程永远采集全景</strong> —— 一线程异常多线程有因。  </li>
<li><strong>善用脚本记录可重复性。</strong>  </li>
<li><strong>core 是真相，不依赖复现。</strong>  </li>
<li><strong>源码 + 汇编 &#x3D; 真图谱。</strong>  </li>
<li><strong>越自动越低风险。</strong>  </li>
<li><strong>永不在生产 attach 长时。</strong>  </li>
<li><strong>多用 batch 模式采样。</strong>  </li>
<li><strong>离线分析，安全优先。</strong></li>
</ol>
<hr>
]]></content>
  </entry>
  <entry>
    <title>linux内核探秘pdf</title>
    <url>/linux%E5%86%85%E6%A0%B8%E6%8E%A2%E7%A7%98pdf/</url>
    <content><![CDATA[<span id="more"></span>
<embed src="linux-filesystem-driver.pdf" width="100%" height="1000" type="application/pdf">


]]></content>
  </entry>
  <entry>
    <title>CMAKE完全手册</title>
    <url>/CMAKE%E5%AE%8C%E5%85%A8%E6%89%8B%E5%86%8C/</url>
    <content><![CDATA[<p>配合CMake简明教程使用，细节更多, 日常小项目，简明手册的工程模板完全够用,这个教程末尾的模板就是更符合国际惯例一些</p>
<span id="more"></span>

<hr>
<h1 id="🧱-第-1-章-CMake-变量系统全解（脚本语法核心）"><a href="#🧱-第-1-章-CMake-变量系统全解（脚本语法核心）" class="headerlink" title="🧱 第 1 章 | CMake 变量系统全解（脚本语法核心）"></a>🧱 第 1 章 | CMake 变量系统全解（脚本语法核心）</h1><hr>
<h2 id="1-变量类型与定义规则"><a href="#1-变量类型与定义规则" class="headerlink" title="1. 变量类型与定义规则"></a>1. 变量类型与定义规则</h2><p>CMake 的脚本世界里，一切都是字符串变量（无显式数据类型）。<br>语法结构：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(&lt;变量名&gt; &lt;值&gt; [CACHE &lt;类型&gt; &lt;描述&gt; [FORCE]])</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_NAME <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;name = $&#123;MY_NAME&#125;&quot;</span>)  <span class="comment"># 输出：name = Alice</span></span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong>  </p>
<ul>
<li>变量区分大小写；  </li>
<li>默认作用域是当前文件；  </li>
<li>在函数 function 内是局部作用域；在 macro 则共享外层；  </li>
<li><code>$&#123;变量名&#125;</code> 取值，不能省 <code>$&#123;&#125;</code>。</li>
</ul>
<hr>
<h2 id="2-三类主要变量"><a href="#2-三类主要变量" class="headerlink" title="2. 三类主要变量"></a>2. 三类主要变量</h2><table>
<thead>
<tr>
<th>分类</th>
<th>定义方式</th>
<th>生命周期 &#x2F; 存储位置</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>普通变量</td>
<td><code>set(VAR val)</code></td>
<td>当前作用域</td>
<td><code>set(A 5)</code></td>
</tr>
<tr>
<td>缓存变量</td>
<td><code>set(VAR val CACHE TYPE DESC)</code></td>
<td>写入 CMakeCache.txt</td>
<td>构建配置选项</td>
</tr>
<tr>
<td>环境变量</td>
<td><code>set(ENV&#123;VAR&#125; val)</code></td>
<td>传递给外部命令环境</td>
<td><code>set(ENV&#123;PATH&#125; /opt/bin:$ENV&#123;PATH&#125;)</code></td>
</tr>
</tbody></table>
<p>🔹 <strong>环境变量示例：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(<span class="string">&quot;before = $ENV&#123;PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(ENV&#123;PATH&#125; <span class="string">&quot;/extra:$ENV&#123;PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">execute_process</span>(<span class="keyword">COMMAND</span> env)  <span class="comment"># 生成过程中的环境可用</span></span><br></pre></td></tr></table></figure>

<p>🔹 <strong>缓存变量示例：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(BUILD_VERBOSE <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;Show build details&quot;</span>)</span><br><span class="line"><span class="comment"># 命令行：cmake -DBUILD_VERBOSE=ON ..</span></span><br></pre></td></tr></table></figure>

<p>缓存变量可用于生成配置选项界面（ccmake &#x2F; CMake GUI），值持久化在当前 build 目录，除非加 FORCE 才会覆盖。</p>
<hr>
<h2 id="3-变量作用域示例"><a href="#3-变量作用域示例" class="headerlink" title="3. 变量作用域示例"></a>3. 变量作用域示例</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(V outer)</span><br><span class="line"><span class="keyword">function</span>(<span class="keyword">test</span>)</span><br><span class="line">  <span class="keyword">set</span>(V inner)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;in function: $&#123;V&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"><span class="keyword">test</span>()</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;outside: $&#123;V&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">in function: inner</span><br><span class="line">outside: outer</span><br></pre></td></tr></table></figure>

<p>function 内部不会修改外层；<br>若用 macro 定义，则作用域共享，会改动外层。  </p>
<hr>
<h2 id="4-列表与字符串操作"><a href="#4-列表与字符串操作" class="headerlink" title="4. 列表与字符串操作"></a>4. 列表与字符串操作</h2><h3 id="4-1-列表基础"><a href="#4-1-列表基础" class="headerlink" title="4.1 列表基础"></a>4.1 列表基础</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYLIST A B C)</span><br><span class="line"><span class="keyword">list</span>(APPEND MYLIST D)</span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS MYLIST)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;item=$&#123;item&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<h3 id="4-2-常用-list-子命令"><a href="#4-2-常用-list-子命令" class="headerlink" title="4.2 常用 list() 子命令"></a>4.2 常用 list() 子命令</h3><table>
<thead>
<tr>
<th>子命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>APPEND</td>
<td>追加</td>
</tr>
<tr>
<td>LENGTH</td>
<td>获取长度</td>
</tr>
<tr>
<td>GET i</td>
<td>取元素</td>
</tr>
<tr>
<td>REMOVE_ITEM</td>
<td>删除匹配项</td>
</tr>
<tr>
<td>JOIN</td>
<td>合并为字符串</td>
</tr>
</tbody></table>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(JOIN MYLIST <span class="string">&quot;,&quot;</span> JOINED)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;$&#123;JOINED&#125;&quot;</span>)  <span class="comment"># → A,B,C,D</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="4-3-字符串处理"><a href="#4-3-字符串处理" class="headerlink" title="4.3 字符串处理"></a>4.3 字符串处理</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(TOUPPER <span class="string">&quot;abc&quot;</span> OUT)     <span class="comment"># 变大写</span></span><br><span class="line"><span class="keyword">string</span>(SUBSTRING <span class="string">&quot;abcdef&quot;</span> <span class="number">0</span> <span class="number">3</span> FIRST)</span><br><span class="line"><span class="keyword">string</span>(REPLACE <span class="string">&quot;a&quot;</span> <span class="string">&quot;x&quot;</span> CHANGED <span class="string">&quot;$&#123;VAR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">string</span>(FIND <span class="string">&quot;$&#123;TEXT&#125;&quot;</span> <span class="string">&quot;key&quot;</span> POS)</span><br></pre></td></tr></table></figure>

<p>📘 CMake 字符串操作统统生成新变量，不会原地修改。  </p>
<hr>
<h2 id="5-预定义路径变量（必须熟）"><a href="#5-预定义路径变量（必须熟）" class="headerlink" title="5. 预定义路径变量（必须熟）"></a>5. 预定义路径变量（必须熟）</h2><table>
<thead>
<tr>
<th>变量</th>
<th>解释</th>
<th>典型值</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_SOURCE_DIR</code></td>
<td>顶层 CMakeLists.txt 所在源码根</td>
<td><code>/home/user/demo</code></td>
</tr>
<tr>
<td><code>CMAKE_CURRENT_SOURCE_DIR</code></td>
<td>当前 CMakeLists 所在源码目录</td>
<td><code>/home/user/demo/Core</code></td>
</tr>
<tr>
<td><code>CMAKE_BINARY_DIR</code></td>
<td>顶层构建目录</td>
<td><code>/home/user/demo/build</code></td>
</tr>
<tr>
<td><code>CMAKE_CURRENT_BINARY_DIR</code></td>
<td>当前子目录构建目录</td>
<td><code>/home/user/demo/build/Core</code></td>
</tr>
<tr>
<td><code>PROJECT_SOURCE_DIR</code></td>
<td>定义 project() 的目录</td>
<td>同 CMAKE_SOURCE_DIR</td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_PREFIX</code></td>
<td>安装目标根目录</td>
<td><code>/usr/local</code> 或手动 -prefix</td>
</tr>
<tr>
<td><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code></td>
<td>可执行输出路径</td>
<td><code>$&#123;CMAKE_SOURCE_DIR&#125;/bin</code></td>
</tr>
<tr>
<td><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code></td>
<td>动态库输出路径</td>
<td><code>$&#123;CMAKE_SOURCE_DIR&#125;/bin/lib</code></td>
</tr>
<tr>
<td><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code></td>
<td>静态库输出路径</td>
<td><code>$&#123;CMAKE_SOURCE_DIR&#125;/bin/lib</code></td>
</tr>
</tbody></table>
<p><strong>范例：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br></pre></td></tr></table></figure>
<p>→ <code>bin/app</code> 生成在源码的 bin 目录。</p>
<hr>
<h2 id="6-路径与文件辅助变量"><a href="#6-路径与文件辅助变量" class="headerlink" title="6. 路径与文件辅助变量"></a>6. 路径与文件辅助变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>内容</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_CURRENT_FUNCTION_LIST_DIR</code></td>
<td>当前函数所在文件路径</td>
<td>模块内引入相对路径</td>
</tr>
<tr>
<td><code>CMAKE_COMMAND</code></td>
<td>当前 cmake 可执行路径</td>
<td>用于 add_custom_command 调用</td>
</tr>
<tr>
<td><code>CMAKE_MODULE_PATH</code></td>
<td>搜索 FindXXX.cmake 的额外目录</td>
<td><code>set(CMAKE_MODULE_PATH &quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;)</code></td>
</tr>
<tr>
<td><code>CMAKE_GENERATOR</code></td>
<td>当前生成器（Ninja &#x2F; Makefiles &#x2F; MSVC）</td>
<td>条件判断</td>
</tr>
<tr>
<td><code>CMAKE_SYSTEM_NAME</code></td>
<td>操作系统标识</td>
<td>交叉编译判断</td>
</tr>
<tr>
<td><code>CMAKE_CXX_COMPILER_ID</code></td>
<td>编译器标识</td>
<td>GCC &#x2F; Clang &#x2F; MSVC</td>
</tr>
<tr>
<td><code>CMAKE_BUILD_TYPE</code></td>
<td>构建类型</td>
<td>Debug &#x2F; Release …</td>
</tr>
</tbody></table>
<hr>
<h2 id="7-变量存在性与默认值处理"><a href="#7-变量存在性与默认值处理" class="headerlink" title="7. 变量存在性与默认值处理"></a>7. 变量存在性与默认值处理</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">DEFINED</span> VAR)</span><br><span class="line">  <span class="keyword">message</span>(<span class="string">&quot;VAR is defined&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">NOT</span> <span class="keyword">DEFINED</span> SOME_OPTION)</span><br><span class="line">  <span class="keyword">set</span>(SOME_OPTION <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-高级技巧：父作用域-复合路径"><a href="#8-高级技巧：父作用域-复合路径" class="headerlink" title="8. 高级技巧：父作用域 &amp; 复合路径"></a>8. 高级技巧：父作用域 &amp; 复合路径</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在子函数修改外层值</span></span><br><span class="line"><span class="keyword">function</span>(setFlag)</span><br><span class="line">  <span class="keyword">set</span>(MODE ready PARENT_SCOPE)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line">setFlag()</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;MODE=$&#123;MODE&#125;&quot;</span>)  <span class="comment"># → ready</span></span><br></pre></td></tr></table></figure>

<p>复合路径构建：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(DIR /home)</span><br><span class="line"><span class="keyword">set</span>(PATH <span class="variable">$&#123;DIR&#125;</span>/<span class="keyword">project</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-小结与常见误区"><a href="#9-小结与常见误区" class="headerlink" title="9. 小结与常见误区"></a>9. 小结与常见误区</h2><table>
<thead>
<tr>
<th>情形</th>
<th>问题</th>
<th>修复方式</th>
</tr>
</thead>
<tbody><tr>
<td>使用 <code>$VAR</code> 而非 <code>$&#123;VAR&#125;</code></td>
<td>解释为空字符串</td>
<td>始终加花括号</td>
</tr>
<tr>
<td>想改父作用域变量不起作用</td>
<td>function 有局部作用域</td>
<td>使用 PARENT_SCOPE</td>
</tr>
<tr>
<td>新文件未被检测到</td>
<td>使用 file(GLOB)</td>
<td>显式列源码或触发 reconfigure</td>
</tr>
<tr>
<td>想跨 build 保存设置</td>
<td>用 CACHE 变量</td>
<td><code>set(VAR val CACHE ...)</code></td>
</tr>
<tr>
<td>需要环境变量更新</td>
<td>需在执行命令前 set(ENV{})</td>
<td>否则已启动的构建不会继承</td>
</tr>
</tbody></table>
<hr>
<p>到此，第 1 章覆盖：</p>
<ul>
<li>变量定义与3种类型  </li>
<li>作用域与函数&#x2F;宏差异  </li>
<li>list &#x2F; string 常用操作  </li>
<li>预定义路径与系统变量  </li>
<li>缓存、环境及父作用域技巧</li>
</ul>
<hr>
<hr>
<h1 id="⚙️-第-2-章-CMake-目标-Target-体系与依赖机制全解"><a href="#⚙️-第-2-章-CMake-目标-Target-体系与依赖机制全解" class="headerlink" title="⚙️ 第 2 章 | CMake 目标 (Target) 体系与依赖机制全解"></a>⚙️ 第 2 章 | CMake 目标 (Target) 体系与依赖机制全解</h1><hr>
<h2 id="2-1-Target-是什么"><a href="#2-1-Target-是什么" class="headerlink" title="2.1 Target 是什么"></a>2.1 Target 是什么</h2><p>在 CMake 里，<strong>目标(Target)</strong> 是一种「可构建实体」。<br>每一个 <code>add_executable()</code>、<code>add_library()</code> 调用后，都会在内部产生一个 Target 对象，记录它的：</p>
<ul>
<li>源文件集合  </li>
<li>编译&#x2F;链接参数  </li>
<li>导出名称  </li>
<li>安装位置  </li>
<li>与其他 Target 的关系</li>
</ul>
<p>这些目标被编译工具（Ninja &#x2F; Makefile &#x2F; MSVC …）映射成真实的构建单元。<br>所有依赖关系、头文件路径、宏定义，最终都绑定在Target 上。</p>
<hr>
<h3 id="2-1-1-创建目标"><a href="#2-1-1-创建目标" class="headerlink" title="2.1.1 创建目标"></a>2.1.1 创建目标</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(core STATIC core.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(net SHARED net.cpp)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
<th>输出形式</th>
</tr>
</thead>
<tbody><tr>
<td><code>STATIC</code></td>
<td>静态库</td>
<td>libcore.a &#x2F; core.lib</td>
</tr>
<tr>
<td><code>SHARED</code></td>
<td>动态库</td>
<td>libnet.so &#x2F; net.dll</td>
</tr>
<tr>
<td><code>MODULE</code></td>
<td>插件模块库</td>
<td>仅 <code>dlopen</code>&#x2F;<code>LoadLibrary</code> 调用加载</td>
</tr>
<tr>
<td><em>(无类型)</em></td>
<td>由变量 <code>BUILD_SHARED_LIBS</code> 控制</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>⚙️ <code>add_library(core core.cpp)</code> 会在变量 <code>BUILD_SHARED_LIBS</code> 为 ON 时自动生成共享库。  </p>
</blockquote>
<hr>
<h3 id="2-1-2-目标命名与路径属性"><a href="#2-1-2-目标命名与路径属性" class="headerlink" title="2.1.2 目标命名与路径属性"></a>2.1.2 目标命名与路径属性</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(core PROPERTIES</span><br><span class="line">  OUTPUT_NAME <span class="string">&quot;MyCore&quot;</span>            <span class="comment"># 生成文件名</span></span><br><span class="line">  ARCHIVE_OUTPUT_DIRECTORY lib    <span class="comment"># 静态库路径</span></span><br><span class="line">  LIBRARY_OUTPUT_DIRECTORY lib    <span class="comment"># 动态库路径</span></span><br><span class="line">  RUNTIME_OUTPUT_DIRECTORY bin    <span class="comment"># 可执行输出路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>📘 属性控制单个目标的生成行为。可随时 <code>get_target_property()</code> 读取。</p>
<hr>
<h2 id="2-2-target-link-libraries：建立依赖关系"><a href="#2-2-target-link-libraries：建立依赖关系" class="headerlink" title="2.2 target_link_libraries：建立依赖关系"></a>2.2 target_link_libraries：建立依赖关系</h2><p>这是最常用命令，用于告诉 CMake 如何把一个目标连接到另一个目标或系统库。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE core pthread)</span><br></pre></td></tr></table></figure>

<p><strong>完整语法：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(&lt;<span class="keyword">target</span>&gt;</span><br><span class="line">  [PRIVATE|PUBLIC|INTERFACE] &lt;item&gt; [&lt;item&gt;...])</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
<th>传播方式</th>
</tr>
</thead>
<tbody><tr>
<td>PRIVATE</td>
<td>仅当前目标生效</td>
<td>不传播</td>
</tr>
<tr>
<td>PUBLIC</td>
<td>当前目标及其依赖的下游目标</td>
<td>传播</td>
</tr>
<tr>
<td>INTERFACE</td>
<td>本目标不使用，但下游使用</td>
<td>仅传播</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(A a.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(B b.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(B PUBLIC A)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE B)</span><br><span class="line"><span class="comment"># app 自动获得对 A 的链接：B 公布了 A 作为 PUBLIC 依赖</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="常见场景举例"><a href="#常见场景举例" class="headerlink" title="常见场景举例"></a>常见场景举例</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Header-only 库</span></span><br><span class="line"><span class="keyword">add_library</span>(utils INTERFACE)</span><br><span class="line"><span class="keyword">target_include_directories</span>(utils INTERFACE <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 普通库应用</span></span><br><span class="line"><span class="keyword">add_library</span>(core src/core.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE core utils)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-3-target-include-directories：头文件路径"><a href="#2-3-target-include-directories：头文件路径" class="headerlink" title="2.3 target_include_directories：头文件路径"></a>2.3 target_include_directories：头文件路径</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(core</span><br><span class="line">  PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>修饰符</th>
<th>作用范围</th>
</tr>
</thead>
<tbody><tr>
<td>PRIVATE</td>
<td>本目标可见</td>
</tr>
<tr>
<td>INTERFACE</td>
<td>仅依赖者可见</td>
</tr>
<tr>
<td>PUBLIC</td>
<td>两者都可见</td>
</tr>
</tbody></table>
<p>📘 推荐做法：每个库在自己的 CMakeLists 里通过 target_include_directories 公布路径，而不是全局 include_directories()。  </p>
<hr>
<h2 id="2-4-target-compile-definitions：编译宏"><a href="#2-4-target-compile-definitions：编译宏" class="headerlink" title="2.4 target_compile_definitions：编译宏"></a>2.4 target_compile_definitions：编译宏</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(core</span><br><span class="line">  PRIVATE CORE_EXPORTS</span><br><span class="line">  PUBLIC CORE_API_LEVEL=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>相当于编译命令中增加 <code>-DCORE_EXPORTS</code> &#x2F; <code>-DCORE_API_LEVEL=2</code>。<br>使用修饰符控制传播范围。</p>
<hr>
<h2 id="2-5-target-compile-options：添加编译器标志"><a href="#2-5-target-compile-options：添加编译器标志" class="headerlink" title="2.5 target_compile_options：添加编译器标志"></a>2.5 target_compile_options：添加编译器标志</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_options</span>(core PRIVATEWall -Wextra)</span><br><span class="line"><span class="keyword">target_compile_options</span>(app PUBLIC -O2)</span><br></pre></td></tr></table></figure>

<ul>
<li>可为不同目标定义不同编译参数；  </li>
<li>支持 PRIVATE &#x2F; PUBLIC 同样修饰词。</li>
</ul>
<hr>
<h2 id="2-6-目标属性-与-get-set"><a href="#2-6-目标属性-与-get-set" class="headerlink" title="2.6 目标属性 与 get&#x2F;set"></a>2.6 目标属性 与 get&#x2F;set</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_target_properties</span>(app PROPERTIES CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">get_target_property</span>(standard app CXX_STANDARD)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;C++ standard for app = $&#123;standard&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>常用属性：</p>
<table>
<thead>
<tr>
<th>属性名</th>
<th>功能</th>
<th>取值</th>
</tr>
</thead>
<tbody><tr>
<td>CXX_STANDARD</td>
<td>++ 标准版本</td>
<td>11 &#x2F; 14 &#x2F; 17 &#x2F; 20 …</td>
</tr>
<tr>
<td>POSITION_INDEPENDENT_CODE</td>
<td>控制 fPIC</td>
<td>ON &#x2F; OFF</td>
</tr>
<tr>
<td>LINKER_LANGUAGE</td>
<td>指定链接语言</td>
<td>C &#x2F; CXX</td>
</tr>
<tr>
<td>OUTPUT_NAME</td>
<td>输出名</td>
<td>例如 MyApp</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-7-导入与接口目标"><a href="#2-7-导入与接口目标" class="headerlink" title="2.7 导入与接口目标"></a>2.7 导入与接口目标</h2><h3 id="2-7-1-IMPORTED"><a href="#2-7-1-IMPORTED" class="headerlink" title="2.7.1 IMPORTED"></a>2.7.1 IMPORTED</h3><p>代表外部已存在的库，不参与构建：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(MyExternal UNKNOWN IMPORTED)</span><br><span class="line"><span class="keyword">set_target_properties</span>(MyExternal PROPERTIES</span><br><span class="line">  IMPORTED_LOCATION /usr/lib/libext.so</span><br><span class="line">  INTERFACE_INCLUDE_DIRECTORIES /usr/<span class="keyword">include</span>/ext)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE MyExternal)</span><br></pre></td></tr></table></figure>

<h3 id="2-7-2-INTERFACE"><a href="#2-7-2-INTERFACE" class="headerlink" title="2.7.2 INTERFACE"></a>2.7.2 INTERFACE</h3><p>Header‑only 或纯接口目标：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(header_only INTERFACE)</span><br><span class="line"><span class="keyword">target_include_directories</span>(header_only INTERFACE <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<p>不会编译，只有接口属性。</p>
<hr>
<h2 id="2-8-命名空间-NAMESPACE"><a href="#2-8-命名空间-NAMESPACE" class="headerlink" title="2.8 命名空间 (NAMESPACE)"></a>2.8 命名空间 (NAMESPACE)</h2><p>CMake 建议为导出的 target 使用「命名空间::名称」格式。<br>例如 <code>find_package(OpenCV)</code> 后可使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE OpenCV::core)</span><br></pre></td></tr></table></figure>

<p>当你自己的项目导出时，同样可定义：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjTargets</span><br><span class="line">  NAMESPACE MyProj::</span><br><span class="line">  DESTINATION lib/cmake/MyProj)</span><br></pre></td></tr></table></figure>
<p>使用方：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyProj)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE MyProj::core)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-9-常见错误与排查"><a href="#2-9-常见错误与排查" class="headerlink" title="2.9 常见错误与排查"></a>2.9 常见错误与排查</h2><table>
<thead>
<tr>
<th>问题</th>
<th>现象</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>未找到某库</td>
<td>链接阶段 undefined reference</td>
<td>确认 target_link_libraries 顺序与修饰符</td>
</tr>
<tr>
<td>include 无效</td>
<td>编译时报头找不到</td>
<td>检查 target_include_directories 修饰符</td>
</tr>
<tr>
<td>属性未生效</td>
<td>语法正确但不执行</td>
<td>状态是否设置到正确目标</td>
</tr>
<tr>
<td>无法导出 INTERFACE 目标</td>
<td>错误提示 “target not built”</td>
<td>加上 EXPORT 和 install(EXPORT …) 一起使用</td>
</tr>
</tbody></table>
<hr>
<h2 id="2-10-章节小结"><a href="#2-10-章节小结" class="headerlink" title="2.10 章节小结"></a>2.10 章节小结</h2><blockquote>
<p>一切编译与链接信息都绑定在 Target 对象上。  </p>
</blockquote>
<p><strong>构建依赖链：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add_library(A)</span><br><span class="line">add_library(B)</span><br><span class="line">target_link_libraries(B PUBLIC A)</span><br><span class="line">add_executable(app)</span><br><span class="line">target_link_libraries(app PRIVATE B)</span><br></pre></td></tr></table></figure>
<p>🔁 CMake 自动推导 app → B → A 完整依赖；<br>头文件路径与宏定义按 PUBLIC&#x2F;INTERFACE 传播。</p>
<hr>
<p>🟢 第 2 章讲完，现在你拥有：</p>
<ul>
<li>完整 Target 定义方式  </li>
<li>链接依赖的三层修饰符语义  </li>
<li>include &#x2F; compile &#x2F; macro 属性绑定  </li>
<li>导入目标与命名空间理解</li>
</ul>
<hr>
<hr>
<h1 id="🧩-第-3-章-install-与-export-机制详解"><a href="#🧩-第-3-章-install-与-export-机制详解" class="headerlink" title="🧩 第 3 章 | install() 与 export() 机制详解"></a>🧩 第 3 章 | install() 与 export() 机制详解</h1><hr>
<h2 id="3-1-为什么要-install"><a href="#3-1-为什么要-install" class="headerlink" title="3.1 为什么要 install()"></a>3.1 为什么要 install()</h2><blockquote>
<p>构建器产物 (可执行文件、静态&#x2F;动态库、头文件等) 一般会分发给其他项目或用户使用，<br>CMake 的 <code>install()</code> 用于定义“哪些文件、放到哪里、装成什么结构”。</p>
</blockquote>
<hr>
<h2 id="3-2-基本语法分类"><a href="#3-2-基本语法分类" class="headerlink" title="3.2 基本语法分类"></a>3.2 基本语法分类</h2><ol>
<li><strong>安装目标</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS &lt;targets&gt; [<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-<span class="keyword">set</span>&gt;]</span><br><span class="line">        [RUNTIME DESTINATION &lt;dir&gt;]</span><br><span class="line">        [LIBRARY DESTINATION &lt;dir&gt;]</span><br><span class="line">        [ARCHIVE DESTINATION &lt;dir&gt;]</span><br><span class="line">        [PUBLIC_HEADER DESTINATION &lt;dir&gt;]</span><br><span class="line">        [INCLUDES DESTINATION &lt;dir&gt;])</span><br></pre></td></tr></table></figure></li>
<li><strong>安装普通文件</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES &lt;files&gt; DESTINATION &lt;dir&gt;)</span><br></pre></td></tr></table></figure></li>
<li><strong>安装整个目录</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY &lt;path&gt; DESTINATION &lt;dir&gt; [FILES_MATCHING PATTERN <span class="string">&quot;*.h&quot;</span>])</span><br></pre></td></tr></table></figure></li>
<li><strong>安装导出清单（生成 Config 包）</strong><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> &lt;<span class="keyword">export</span>-<span class="keyword">set</span>&gt;</span><br><span class="line">        <span class="keyword">FILE</span> &lt;config.cmake&gt;</span><br><span class="line">        NAMESPACE &lt;ns&gt;::</span><br><span class="line">        DESTINATION &lt;path&gt;)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="3-3-主要参数说明"><a href="#3-3-主要参数说明" class="headerlink" title="3.3 主要参数说明"></a>3.3 主要参数说明</h2><table>
<thead>
<tr>
<th>子关键字</th>
<th>说明</th>
<th>典型内容</th>
</tr>
</thead>
<tbody><tr>
<td><strong>RUNTIME</strong></td>
<td>可执行文件输出路径</td>
<td><code>$&#123;CMAKE_INSTALL_BINDIR&#125;</code> (<code>bin</code>)</td>
</tr>
<tr>
<td><strong>LIBRARY</strong></td>
<td>动态库(<code>.so/.dll</code>)路径</td>
<td><code>$&#123;CMAKE_INSTALL_LIBDIR&#125;</code></td>
</tr>
<tr>
<td><strong>ARCHIVE</strong></td>
<td>静态库(<code>.a/.lib</code>)路径</td>
<td>同上</td>
</tr>
<tr>
<td><strong>PUBLIC_HEADER</strong></td>
<td>公共头文件安装目录</td>
<td><code>$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</code></td>
</tr>
<tr>
<td><strong>INCLUDES</strong></td>
<td>头文件包含目录提示</td>
<td>供 <code>EXPORT</code> 生成信息使用</td>
</tr>
</tbody></table>
<p>🧠 提示：<br><code>include(GNUInstallDirs)</code> 可获得标准目录变量，如 <code>CMAKE_INSTALL_BINDIR</code>、<code>LIBDIR</code>、<code>INCLUDEDIR</code> 等，便于跨平台统一。</p>
<hr>
<h2 id="3-4-示例：安装库与可执行文件"><a href="#3-4-示例：安装库与可执行文件" class="headerlink" title="3.4 示例：安装库与可执行文件"></a>3.4 示例：安装库与可执行文件</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(GNUInstallDirs)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(core SHARED core.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(core PUBLIC <span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE core)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS core app</span><br><span class="line">  RUNTIME DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span></span><br><span class="line">  LIBRARY DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">  PUBLIC_HEADER DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>/core)</span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --install build --prefix ./install</span><br></pre></td></tr></table></figure>

<p>输出结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install/</span><br><span class="line">├─ bin/app</span><br><span class="line">├─ lib/libcore.so</span><br><span class="line">└─ include/core/core.h</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-5-install-EXPORT-生成-Config-包"><a href="#3-5-install-EXPORT-生成-Config-包" class="headerlink" title="3.5 install(EXPORT) 生成 Config 包"></a>3.5 install(EXPORT) 生成 Config 包</h2><p>让别的项目可以：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyProj REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(other PRIVATE MyProj::core)</span><br></pre></td></tr></table></figure>

<p>就必须导出自身的目标描述文件。</p>
<h3 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h3><p>1️⃣ 注册导出清单名：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS core <span class="keyword">EXPORT</span> MyProjTargets</span><br><span class="line">        LIBRARY DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">        PUBLIC_HEADER DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>/core)</span><br></pre></td></tr></table></figure>
<p>2️⃣ 写出清单到 cmake&#x2F; 目录：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjTargets</span><br><span class="line">        <span class="keyword">FILE</span> MyProjTargets.cmake</span><br><span class="line">        NAMESPACE MyProj::</span><br><span class="line">        DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MyProj)</span><br></pre></td></tr></table></figure>
<p>3️⃣ 生成顶层 Config 文件（可选）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(MyProjConfig.cmake.in</span><br><span class="line">               <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjConfig.cmake&quot;</span> @ONLY)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjConfig.cmake&quot;</span></span><br><span class="line">        DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MyProj)</span><br></pre></td></tr></table></figure>

<p>之后：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --install build --prefix ./package</span><br></pre></td></tr></table></figure>
<p>另一个工程中：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MyProj_DIR <span class="string">&quot;/path/to/package/lib/cmake/MyProj&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(MyProj)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(userApp PRIVATE MyProj::core)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-6-导出清单与命名空间（NAMESPACE）"><a href="#3-6-导出清单与命名空间（NAMESPACE）" class="headerlink" title="3.6 导出清单与命名空间（NAMESPACE）"></a>3.6 导出清单与命名空间（NAMESPACE）</h2><ul>
<li><code>EXPORT &lt;name&gt;</code> 只是一个收集器清单。  </li>
<li><code>NAMESPACE</code> 定义导入目标前缀，用于防止命名冲突。</li>
</ul>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MathKitTargets</span><br><span class="line">        <span class="keyword">FILE</span> MathKitConfig.cmake</span><br><span class="line">        NAMESPACE MathKit::</span><br><span class="line">        DESTINATION lib/cmake/MathKit)</span><br></pre></td></tr></table></figure>

<p>消费者工程即可安全调用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE MathKit::algebra)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-7-install-FILES-DIRECTORY-常规用途"><a href="#3-7-install-FILES-DIRECTORY-常规用途" class="headerlink" title="3.7 install(FILES | DIRECTORY) 常规用途"></a>3.7 install(FILES | DIRECTORY) 常规用途</h2><table>
<thead>
<tr>
<th>命令</th>
<th>用途</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>FILES</td>
<td>安装若干文件</td>
<td><code>install(FILES config.toml DESTINATION etc)</code></td>
</tr>
<tr>
<td>DIRECTORY</td>
<td>拷贝整个目录</td>
<td><code>install(DIRECTORY shaders DESTINATION share)</code></td>
</tr>
<tr>
<td>DIRECTORY + 过滤</td>
<td>仅匹配特定文件</td>
<td><code>install(DIRECTORY include/ DESTINATION include FILES_MATCHING PATTERN &quot;*.h&quot;)</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="3-8-配置文件模板-configure-file"><a href="#3-8-配置文件模板-configure-file" class="headerlink" title="3.8 配置文件模板 configure_file()"></a>3.8 配置文件模板 configure_file()</h2><p>在 install 生成 Config 过程中常需要写入路径信息。  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">configure_file</span>(</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake/MyProjConfig.cmake.in&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/MyProjConfig.cmake&quot;</span></span><br><span class="line">  @ONLY)</span><br></pre></td></tr></table></figure>

<p><strong>模板内容示意：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MyProjConfig.cmake.in</span></span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MyProjTargets.cmake&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MyProj_VERSION <span class="string">&quot;@PROJECT_VERSION@&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>其中 <code>@PROJECT_VERSION@</code> 等占位符会被替换。</p>
<hr>
<h2 id="3-9-常见-install-变量"><a href="#3-9-常见-install-变量" class="headerlink" title="3.9 常见 install 变量"></a>3.9 常见 install 变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_INSTALL_PREFIX</code></td>
<td>安装根路径</td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_BINDIR</code></td>
<td>默认 <code>bin</code></td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_LIBDIR</code></td>
<td>默认 <code>lib</code> &#x2F; <code>lib64</code></td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_INCLUDEDIR</code></td>
<td>默认 <code>include</code></td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_DATADIR</code></td>
<td><code>share</code></td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_SYSCONFDIR</code></td>
<td><code>etc</code></td>
</tr>
</tbody></table>
<p>命令行覆写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --install build --prefix /opt/MyProj</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-10-常见问题-Q-A"><a href="#3-10-常见问题-Q-A" class="headerlink" title="3.10 常见问题 Q&amp;A"></a>3.10 常见问题 Q&amp;A</h2><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>解决</th>
</tr>
</thead>
<tbody><tr>
<td>安装路径不对</td>
<td>忘记包含 GNUInstallDirs</td>
<td><code>include(GNUInstallDirs)</code></td>
</tr>
<tr>
<td>find_package 找不到</td>
<td>未生成 Config.cmake</td>
<td>请加 install(EXPORT…)</td>
</tr>
<tr>
<td>Header 未随库安装</td>
<td>未指定 PUBLIC_HEADER&#x2F;FILES 或路径错误</td>
<td>确认 目标 PUBLIC_HEADER 或显式 install(FILES)</td>
</tr>
<tr>
<td>namespace 失效</td>
<td>没在 install(EXPORT) 里声明 NAMESPACE</td>
<td>补加 NAMESPACE MyProj::</td>
</tr>
</tbody></table>
<hr>
<h2 id="3-11-章节小结"><a href="#3-11-章节小结" class="headerlink" title="3.11 章节小结"></a>3.11 章节小结</h2><p>✅ 本章你应掌握：</p>
<ul>
<li>install 三大用法: (TARGETS &#x2F; FILES &#x2F; DIRECTORY)  </li>
<li>export 导出机制 + 生成 Config 包步骤  </li>
<li>GNUInstallDirs 标准路径集合  </li>
<li>namespace 的意义与使用  </li>
<li>常见错误定位</li>
</ul>
<hr>
<hr>
<h1 id="🔍-第-4-章-find-package-与-CMake-包（Package）机制实战"><a href="#🔍-第-4-章-find-package-与-CMake-包（Package）机制实战" class="headerlink" title="🔍 第 4 章 | find_package() 与 CMake 包（Package）机制实战"></a>🔍 第 4 章 | find_package() 与 CMake 包（Package）机制实战</h1><hr>
<h2 id="4-1-find-package-的使命"><a href="#4-1-find-package-的使命" class="headerlink" title="4.1 find_package 的使命"></a>4.1 find_package 的使命</h2><blockquote>
<p>CMake 允许你复用外部库，但它必须<strong>知道怎么找到这些库</strong>。<br><code>find_package()</code> 就是连接项目依赖与实际路径的桥梁。  </p>
</blockquote>
<p>它会去系统路径及用户指定路径搜索匹配的描述文件来定位并导入库的 Targets。  </p>
<hr>
<h2 id="4-2-两种包模式"><a href="#4-2-两种包模式" class="headerlink" title="4.2 两种包模式"></a>4.2 两种包模式</h2><table>
<thead>
<tr>
<th>模式</th>
<th>文件类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Config 模式</strong></td>
<td><code>&lt;Name&gt;Config.cmake</code> &#x2F; <code>&lt;Name&gt;-config.cmake</code></td>
<td>推荐、现代项目（使用 target）导出使用</td>
</tr>
<tr>
<td><strong>Module 模式</strong></td>
<td><code>Find&lt;Name&gt;.cmake</code></td>
<td>传统手写搜索脚本</td>
</tr>
</tbody></table>
<p><code>find_package(MyProj)</code> 依次尝试：<br>1️⃣ 在路径中查找 <code>MyProjConfig.cmake</code> 或 <code>MyProj-config.cmake</code>;<br>2️⃣ 若找不到，再查是否有 <code>FindMyProj.cmake</code> 模块。  </p>
<hr>
<h2 id="4-3-Config-模式工作原理"><a href="#4-3-Config-模式工作原理" class="headerlink" title="4.3 Config 模式工作原理"></a>4.3 Config 模式工作原理</h2><p>当我们上一章通过  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjTargets</span><br><span class="line">        <span class="keyword">FILE</span> MyProjTargets.cmake</span><br><span class="line">        NAMESPACE MyProj::</span><br><span class="line">        DESTINATION lib/cmake/MyProj)</span><br><span class="line"><span class="keyword">install</span>(FILES MyProjConfig.cmake DESTINATION lib/cmake/MyProj)</span><br><span class="line">```  </span><br><span class="line">生成这些文件后，  </span><br><span class="line">外部项目调用：</span><br><span class="line"></span><br><span class="line">```cmake</span><br><span class="line"><span class="keyword">find_package</span>(MyProj REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE MyProj::core)</span><br></pre></td></tr></table></figure>

<p>CMake 查找顺序（简略）：</p>
<ol>
<li>变量 <code>MyProj_DIR</code> 指定的目录  </li>
<li>系统路径 <code>/usr/lib/cmake/MyProj</code> 等  </li>
<li>用户自定义包注册路径</li>
</ol>
<p>找到 <code>MyProjConfig.cmake</code> 后，该文件执行 <code>include(MyProjTargets.cmake)</code> ，从而导入 MyProj::core。  </p>
<hr>
<h3 id="4-3-1-Config-文件模板快速示例"><a href="#4-3-1-Config-文件模板快速示例" class="headerlink" title="4.3.1 Config 文件模板快速示例"></a>4.3.1 Config 文件模板快速示例</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MyProjConfig.cmake.in</span></span><br><span class="line">@PACKAGE_INIT@</span><br><span class="line"><span class="keyword">include</span>(<span class="string">&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MyProjTargets.cmake&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(MyProj_VERSION <span class="string">&quot;@PROJECT_VERSION@&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>生成：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">configure_package_config_file(</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/MyProjConfig.cmake.in&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjConfig.cmake&quot;</span></span><br><span class="line">  INSTALL_DESTINATION lib/cmake/MyProj)</span><br><span class="line"><span class="keyword">install</span>(FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjConfig.cmake&quot;</span></span><br><span class="line">        DESTINATION lib/cmake/MyProj)</span><br></pre></td></tr></table></figure>

<p>📘 <code>configure_package_config_file</code> 是官方宏（来自 CMakePackageConfigHelpers），<br>会自动填充版本与路径等信息。</p>
<hr>
<h2 id="4-4-Find-模式工作原理"><a href="#4-4-Find-模式工作原理" class="headerlink" title="4.4 Find 模式工作原理"></a>4.4 Find 模式工作原理</h2><p>旧式项目或系统库通常只提供 <code>FindXXX.cmake</code>：</p>
<p>存放在 <code>$CMAKE_MODULE_PATH</code> &#x2F; 系统 Modules 路径下。  </p>
<p>示例（系统自带）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FindThreads.cmake</span><br><span class="line">FindPkgConfig.cmake</span><br><span class="line">FindOpenGL.cmake</span><br><span class="line">FindPython3.cmake</span><br></pre></td></tr></table></figure>

<p>内部基本流程：</p>
<ol>
<li>尝试使用 pkg-config、系统变量、默认路径搜索头文件与库；</li>
<li>若成功设置以下变量：<ul>
<li><code>&lt;Pkg&gt;_FOUND</code></li>
<li><code>&lt;Pkg&gt;_INCLUDE_DIRS</code></li>
<li><code>&lt;Pkg&gt;_LIBRARIES</code></li>
</ul>
</li>
<li>使用示例：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenGL REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE OpenGL::GL)</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="4-5-搜索路径与控制变量"><a href="#4-5-搜索路径与控制变量" class="headerlink" title="4.5 搜索路径与控制变量"></a>4.5 搜索路径与控制变量</h2><table>
<thead>
<tr>
<th>变量 &#x2F;选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;Pkg&gt;_DIR</code></td>
<td>指定 Config 文件目录</td>
</tr>
<tr>
<td><code>CMAKE_PREFIX_PATH</code></td>
<td>附加搜索根</td>
</tr>
<tr>
<td><code>CMAKE_MODULE_PATH</code></td>
<td>附加模块搜索路径</td>
</tr>
<tr>
<td><code>CMAKE_FIND_ROOT_PATH</code></td>
<td>交叉编译根路径</td>
</tr>
<tr>
<td><code>NO_DEFAULT_PATH</code></td>
<td>关闭默认路径搜索</td>
</tr>
<tr>
<td><code>PATHS</code> &#x2F; <code>HINTS</code></td>
<td>临时指明候选路径</td>
</tr>
</tbody></table>
<p>💡 常用例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_PREFIX_PATH <span class="string">&quot;/opt/mylibs;/usr/local&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(MyProj REQUIRED)</span><br></pre></td></tr></table></figure>
<p>或命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_PREFIX_PATH=/opt/mylibs ..</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-6-版本与可选项"><a href="#4-6-版本与可选项" class="headerlink" title="4.6 版本与可选项"></a>4.6 版本与可选项</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Qt6 <span class="number">6.5</span> COMPONENTS Core Gui Widgets REQUIRED)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><strong><code>&lt;Name&gt;</code></strong></td>
<td>包名</td>
</tr>
<tr>
<td><strong><code>&lt;Version&gt;</code></strong></td>
<td>最低版本要求</td>
</tr>
<tr>
<td><strong>COMPONENTS</strong></td>
<td>指定子模块</td>
</tr>
<tr>
<td><strong>CONFIG &#x2F; MODULE</strong></td>
<td>指定搜索模式</td>
</tr>
<tr>
<td><strong>REQUIRED</strong></td>
<td>找不到则立即报错</td>
</tr>
<tr>
<td><strong>QUIET</strong></td>
<td>静默搜索，不提示</td>
</tr>
</tbody></table>
<p>Package 文件可提供：</p>
<ul>
<li><code>&lt;Name&gt;_FOUND</code></li>
<li><code>&lt;Name&gt;_VERSION</code></li>
<li><code>&lt;Name&gt;_COMPONENTS_FOUND</code></li>
</ul>
<hr>
<h2 id="4-7-CMakePackageConfigHelpers-工具"><a href="#4-7-CMakePackageConfigHelpers-工具" class="headerlink" title="4.7 CMakePackageConfigHelpers 工具"></a>4.7 CMakePackageConfigHelpers 工具</h2><p>提供两个核心宏：</p>
<ol>
<li><code>configure_package_config_file()</code>  </li>
<li><code>write_basic_package_version_file()</code></li>
</ol>
<p>生成基础 Config 与 Version 文件，让项目自动支持版本检测。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br><span class="line"></span><br><span class="line">write_basic_package_version_file(</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjConfigVersion.cmake&quot;</span></span><br><span class="line">  VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span></span><br><span class="line">  COMPATIBILITY SameMajorVersion)</span><br><span class="line"><span class="keyword">install</span>(FILES</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjConfigVersion.cmake&quot;</span></span><br><span class="line">  DESTINATION lib/cmake/MyProj)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-8-跨平台-Find-实战举例"><a href="#4-8-跨平台-Find-实战举例" class="headerlink" title="4.8 跨平台 Find 实战举例"></a>4.8 跨平台 Find 实战举例</h2><h3 id="1-查找系统库-OpenSSL"><a href="#1-查找系统库-OpenSSL" class="headerlink" title="(1) 查找系统库 OpenSSL"></a>(1) 查找系统库 OpenSSL</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenSSL REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE OpenSSL::SSL OpenSSL::Crypto)</span><br></pre></td></tr></table></figure>

<h3 id="2-查找自定义包路径"><a href="#2-查找自定义包路径" class="headerlink" title="(2) 查找自定义包路径"></a>(2) 查找自定义包路径</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MyLib_DIR <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/third_party/mylib&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(MyLib CONFIG REQUIRED)</span><br></pre></td></tr></table></figure>

<h3 id="3-使用-pkg-config-模式"><a href="#3-使用-pkg-config-模式" class="headerlink" title="(3) 使用 pkg-config 模式"></a>(3) 使用 pkg-config 模式</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(PkgConfig REQUIRED)</span><br><span class="line">pkg_check_modules(ZLIB REQUIRED zlib)</span><br><span class="line"><span class="keyword">target_include_directories</span>(app PRIVATE <span class="variable">$&#123;ZLIB_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE <span class="variable">$&#123;ZLIB_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-9-查找优先级简化流程"><a href="#4-9-查找优先级简化流程" class="headerlink" title="4.9 查找优先级简化流程"></a>4.9 查找优先级简化流程</h2><p>1️⃣ 直接指定 <code>&lt;Pkg&gt;_DIR</code><br>2️⃣ 查 CMAKE_PREFIX_PATH<br>3️⃣ 查 系统默认路径 (&#x2F;usr&#x2F;lib&#x2F;cmake&#x2F;<Pkg>)<br>4️⃣ 查 CMAKE_MODULE_PATH<br>➡️ 最后 fallback 到内置 FindXXX.cmake  </p>
<hr>
<h2 id="4-10-常见问题与经验"><a href="#4-10-常见问题与经验" class="headerlink" title="4.10 常见问题与经验"></a>4.10 常见问题与经验</h2><table>
<thead>
<tr>
<th>问题</th>
<th>原因</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>包找不到</td>
<td>搜索路径未包含安装目录</td>
<td>设置 <code>&lt;Pkg&gt;_DIR</code> 或 <code>CMAKE_PREFIX_PATH</code></td>
</tr>
<tr>
<td>链接报错</td>
<td>未使用 target 接口</td>
<td>确保目标导出 namespace 并使用 target_link_libraries</td>
</tr>
<tr>
<td>找到了旧版本包</td>
<td>存在多个安装路径</td>
<td>显式指定版本或路径</td>
</tr>
<tr>
<td>“found false” 但头文件存在</td>
<td>无正确 Config 或 Find 模块</td>
<td>自己写 Find 脚本或切换 CONFIG 模式</td>
</tr>
<tr>
<td>交叉编译中找错体系库</td>
<td>PATH 未重定位</td>
<td>设置 <code>CMAKE_FIND_ROOT_PATH_MODE_*</code> 策略</td>
</tr>
</tbody></table>
<hr>
<h2 id="4-11-章节小结"><a href="#4-11-章节小结" class="headerlink" title="4.11 章节小结"></a>4.11 章节小结</h2><p>✅ 本章要点：  </p>
<ul>
<li><strong>两种包模式</strong>：Config (现代) vs Module (传统)  </li>
<li><strong>find_package</strong> 搜索路径与变量控制  </li>
<li><strong>Config&#x2F;Version</strong> 文件生成宏与使用  </li>
<li><strong>传播目标</strong>：通过 namespace 导出的 Target  </li>
<li><strong>常见错误排查方法</strong></li>
</ul>
<hr>
<hr>
<h1 id="🧱-第-5-多目录与子项目管理：add-subdirectory-与-FetchContent-实战"><a href="#🧱-第-5-多目录与子项目管理：add-subdirectory-与-FetchContent-实战" class="headerlink" title="🧱 第 5  | 多目录与子项目管理：add_subdirectory() 与 FetchContent 实战"></a>🧱 第 5  | 多目录与子项目管理：add_subdirectory() 与 FetchContent 实战</h1><hr>
<h2 id="5-1-多目录项目结构的意义"><a href="#5-1-多目录项目结构的意义" class="headerlink" title="5.1 多目录项目结构的意义"></a>5.1 多目录项目结构的意义</h2><p>当项目变大时，单个 CMakeLists.txt 已经难以维护。<br><strong>多层目录结构</strong>可以实现：</p>
<ul>
<li>模块化管理（库 core、网络 net、应用 app 分层）</li>
<li>组件独立编译、复用、单元测试</li>
<li>清晰的依赖链与作用域边界</li>
</ul>
<p>典型示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProj/</span><br><span class="line">├─ CMakeLists.txt            # 顶层</span><br><span class="line">├─ src/</span><br><span class="line">│  ├─ CMakeLists.txt         # 子目录构建核心库</span><br><span class="line">│  └─ core/</span><br><span class="line">│     ├─ CMakeLists.txt</span><br><span class="line">│     └─ core.cpp</span><br><span class="line">├─ app/</span><br><span class="line">│  ├─ CMakeLists.txt</span><br><span class="line">│  └─ main.cpp</span><br><span class="line">└─ tests/</span><br><span class="line">   └─ CMakeLists.txt</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-2-add-subdirectory"><a href="#5-2-add-subdirectory" class="headerlink" title="5.2 add_subdirectory()"></a>5.2 add_subdirectory()</h2><p>顶层 CMakeLists 中注册构建的子目录：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(app)</span><br><span class="line"><span class="keyword">enable_testing</span>()</span><br><span class="line"><span class="keyword">add_subdirectory</span>(tests)</span><br></pre></td></tr></table></figure>

<p>语法：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">add_sub(&lt;dir&gt; [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>&lt;dir&gt;</code></td>
<td>子目录相对路径</td>
</tr>
<tr>
<td><code>binary_dir</code></td>
<td>指定构建输出目录（默认 build 树内同路径）</td>
</tr>
<tr>
<td>&#96;EXCLUDE_FROM_ALL</td>
<td>子项目不会随主项目默认目标编译</td>
</tr>
</tbody></table>
<p>⚙️ 每个子目录都可以像独立项目一样使用 add_library、add_executable 等命令，<br>且继承顶层的 变量、缓存、选项。  </p>
<hr>
<h2 id="5-3-作用域与变量传播规则"><a href="#5-3-作用域与变量传播规则" class="headerlink" title="5.3 作用域与变量传播规则"></a>5.3 作用域与变量传播规则</h2><ul>
<li><strong>变量</strong>：<code>set(VAR value)</code> 默认只在当前文件和更低层 可见，除非声明 <code>CACHE</code> 或 <code>PARENT_SCOPE</code>。  </li>
<li><strong>目标</strong>：所有子目录 add_library&#x2F;add_executable 产生的 Target 在全局可见（可跨目录使用 target_link_libraries）。  </li>
<li>**选项(Option)**：顶层 option() 定义后，子目录都可 ON&#x2F;OFF 控制。</li>
</ul>
<p>例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 顶层</span></span><br><span class="line"><span class="keyword">option</span>(ENABLE_NET <span class="string">&quot;Build net module&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_NET)</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(src/net)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-4-子项目间依赖"><a href="#5-4-子项目间依赖" class="headerlink" title="5.4 子项目间依赖"></a>5.4 子项目间依赖</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/core/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(core core.cpp core.h)</span><br><span class="line"><span class="keyword">target_include_directories</span>(core PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># app/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE core)</span><br></pre></td></tr></table></figure>
<p>⮕ 这样即可在顶层构建时自动按依赖顺序编译。</p>
<hr>
<h2 id="5-5-EXCLUDE-FROM-ALL-的使用场景"><a href="#5-5-EXCLUDE-FROM-ALL-的使用场景" class="headerlink" title="5.5 EXCLUDE_FROM_ALL 的使用场景"></a>5.5 EXCLUDE_FROM_ALL 的使用场景</h2><p>某些子模块（例如测试、工具）只在需要时编译:</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(tools EXCLUDE_FROM_ALL)</span><br></pre></td></tr></table></figure>
<p>除非显式调用 <code>cmake --build . --target toolname</code>，否则不会参与默认 <code>all</code> 目标。</p>
<hr>
<h2 id="5-6-外部子项目管理方案一：add-subdirectory-FetchContent"><a href="#5-6-外部子项目管理方案一：add-subdirectory-FetchContent" class="headerlink" title="5.6 外部子项目管理方案一：add_subdirectory + FetchContent"></a>5.6 外部子项目管理方案一：add_subdirectory + FetchContent</h2><blockquote>
<p>“不安装外部依赖，也能达成跨项目构建”  </p>
</blockquote>
<p>从 CMake 3.11 开始提供的 <strong>FetchContent</strong> 模块，让你在配置阶段下载并添加外部源码。</p>
<hr>
<h3 id="5-6-1-基本流程"><a href="#5-6-1-基本流程" class="headerlink" title="5.6.1 基本流程"></a>5.6.1 基本流程</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line"></span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  spdlog</span><br><span class="line">  GIT_REPOSITORY https://github.com/gabime/spdlog.git</span><br><span class="line">  GIT_TAG        v1.<span class="number">11.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动下载 + add_subdirectory</span></span><br><span class="line">FetchContent_MakeAvailable(spdlog)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>一旦执行后，你就可以直接：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE spdlog::spdlog)</span><br></pre></td></tr></table></figure>
<p>无需额外 find_package。</p>
</blockquote>
<hr>
<h3 id="5-6-2-可选参数"><a href="#5-6-2-可选参数" class="headerlink" title="5.6.2 可选参数"></a>5.6.2 可选参数</h3><table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>URL</code> &#x2F; <code>URL_HASH</code></td>
<td>HTTP 包下载（zip&#x2F;tar.gz）</td>
</tr>
<tr>
<td><code>GIT_REPOSITORY</code> &#x2F; <code>GIT_TAG</code></td>
<td>Git 仓库源码</td>
</tr>
<tr>
<td><code>SOURCE_DIR</code></td>
<td>已有源码路径，可跳过下载</td>
</tr>
<tr>
<td><code>SYSTEM</code></td>
<td>将目录标记为系统库路径（避免警告）</td>
</tr>
</tbody></table>
<p>示例 — 下载 fmt：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">FetchContent_Declare(fmt</span><br><span class="line">  URL https://github.com/fmtlib/fmt/archive/<span class="number">9.1</span>.<span class="number">0</span>.tar.gz)</span><br><span class="line">FetchContent_MakeAvailable(fmt)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-7-外部子项目管理方案二：ExternalProject-Add"><a href="#5-7-外部子项目管理方案二：ExternalProject-Add" class="headerlink" title="5.7 外部子项目管理方案二：ExternalProject_Add"></a>5.7 外部子项目管理方案二：ExternalProject_Add</h2><p>区别：  </p>
<ul>
<li><strong>ExternalProject_Add</strong> 在 <em>构建阶段</em> 下载并单独执行安装（不会直接作为子目录）。  </li>
<li><strong>FetchContent</strong> 在 <em>配置阶段</em> 下载并直接编入当前构建树。</li>
</ul>
<table>
<thead>
<tr>
<th>特性</th>
<th>FetchContent</th>
<th>ExternalProject_Add</th>
</tr>
</thead>
<tbody><tr>
<td>下载时机</td>
<td>配置阶段</td>
<td>构建阶段</td>
</tr>
<tr>
<td>是否变成本地 target</td>
<td>✅ 是（add_subdirectory）</td>
<td>❌ 独立</td>
</tr>
<tr>
<td>编译依赖自动传播</td>
<td>✅</td>
<td>❌（要手动导入）</td>
</tr>
<tr>
<td>用途</td>
<td>Header-only、小中型库</td>
<td>巨型工程、第三方工具链</td>
</tr>
</tbody></table>
<p>示意：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(ExternalProject)</span><br><span class="line">ExternalProject_Add(googletest</span><br><span class="line">  GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">  GIT_TAG release-<span class="number">1.13</span>.<span class="number">0</span></span><br><span class="line">  PREFIX <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/_deps</span><br><span class="line">  INSTALL_COMMAND <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-8-多目录项目实践示例"><a href="#5-8-多目录项目实践示例" class="headerlink" title="5.8 多目录项目实践示例"></a>5.8 多目录项目实践示例</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 顶层 CMakeLists.txt</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.22</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProj VERSION <span class="number">1.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(spdlog</span><br><span class="line">  GIT_REPOSITORY https://github.com/gabime/spdlog.git</span><br><span class="line">  GIT_TAG v1.<span class="number">11.0</span>)</span><br><span class="line">FetchContent_MakeAvailable(spdlog)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(app)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_library</span>(core core.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(core PUBLIC spdlog::spdlog)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># app/CMakeLists.txt</span></span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE core)</span><br></pre></td></tr></table></figure>

<p>构建：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line">cmake --build build -j</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-9-多目录组织经验"><a href="#5-9-多目录组织经验" class="headerlink" title="5.9 多目录组织经验"></a>5.9 多目录组织经验</h2><ul>
<li>每层的 CMakeLists.txt 职责清晰，尽量只描述当前层目标。  </li>
<li>变量和常量尽量在顶层设置（编译选项、全局定义等）。  </li>
<li>使用 <code>PRIVATE/PUBLIC/INTERFACE</code> 控制属性传播范围。  </li>
<li>大型项目建议配合 install&#x2F;export 生成统一 Config 包。  </li>
<li>外部依赖推荐 FetchContent 或 已经 Config 化 的库。  </li>
<li>若被多项目复用，可单独维护为 git 子模块 + add_subdirectory。</li>
</ul>
<hr>
<h2 id="5-10-章节小结"><a href="#5-10-章节小结" class="headerlink" title="5.10 章节小结"></a>5.10 章节小结</h2><p>✅ 本章掌握：</p>
<ul>
<li><strong>多目录结构</strong> 及其层次化管理模式  </li>
<li><strong>add_subdirectory</strong> 管理内部组件  </li>
<li><strong>作用域与变量传递规则</strong>  </li>
<li><strong>EXCLUDE_FROM_ALL</strong> 选项应用  </li>
<li><strong>FetchContent</strong> 快速拉取外部依赖  </li>
<li><strong>ExternalProject_Add</strong> 独立外部构建方案  </li>
<li>组织大型工程的常见建议</li>
</ul>
<hr>
<hr>
<h1 id="⚙️-第-6-章-构建类型（Debug-Release）与多配置、多平台策略"><a href="#⚙️-第-6-章-构建类型（Debug-Release）与多配置、多平台策略" class="headerlink" title="⚙️ 第 6 章 | 构建类型（Debug&#x2F;Release）与多配置、多平台策略"></a>⚙️ 第 6 章 | 构建类型（Debug&#x2F;Release）与多配置、多平台策略</h1><hr>
<h2 id="6-1-构建类型的核心概念"><a href="#6-1-构建类型的核心概念" class="headerlink" title="6.1 构建类型的核心概念"></a>6.1 构建类型的核心概念</h2><blockquote>
<p>“构建类型”决定编译优化级别、调试符号、宏定义等编译条件。<br>在 CMake 中，它由变量 <code>CMAKE_BUILD_TYPE</code> 或多配置生成器控制。  </p>
</blockquote>
<hr>
<h2 id="6-2-单配置生成器-🧩"><a href="#6-2-单配置生成器-🧩" class="headerlink" title="6.2 单配置生成器 🧩"></a>6.2 单配置生成器 🧩</h2><p>典型代表：<br>GCC、Clang、Makefiles、Ninja  </p>
<p>📄 在这种生成器下，构建类型通过变量  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</span><br><span class="line">```  </span><br><span class="line">在 **配置阶段固定**，接着编译时仅存在这一种。  </span><br><span class="line"></span><br><span class="line">| 常用构建类型 | 默认宏 | 优化状态 |</span><br><span class="line">|---------------|---------|----------|</span><br><span class="line">| Debug | `DEBUG`, `NDEBUG` 未定义 | 无优化 + 调试符号 |</span><br><span class="line">| Release | `NDEBUG` | 高优化、去符号 |</span><br><span class="line">| RelWithDebInfo | `NDEBUG` | 优化 + 调试符号 |</span><br><span class="line">| MinSizeRel | `NDEBUG` | 微优化体积 |</span><br><span class="line"></span><br><span class="line">可查看内置选项：</span><br><span class="line">```bash</span><br><span class="line">cmake --help-variable CMAKE_BUILD_TYPE</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-3-多配置生成器-🧩"><a href="#6-3-多配置生成器-🧩" class="headerlink" title="6.3 多配置生成器 🧩"></a>6.3 多配置生成器 🧩</h2><p>典型代表：<br>Visual Studio、Xcode、Ninja Multi-Config  </p>
<p>📦 在这种生成器中 CMake 一次生成所有配置，<br>构建时再指定配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --build build --config Debug</span><br><span class="line">cmake --build build --config Release</span><br></pre></td></tr></table></figure>

<p>无需再设置 <code>CMAKE_BUILD_TYPE</code>。</p>
<hr>
<h2 id="6-4-定义自定义构建类型（进阶）"><a href="#6-4-定义自定义构建类型（进阶）" class="headerlink" title="6.4 定义自定义构建类型（进阶）"></a>6.4 定义自定义构建类型（进阶）</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CONFIGURATION_TYPES <span class="string">&quot;Debug;Release;ASan&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_ASan <span class="string">&quot;-fsanitize=address -O1 -g&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;&quot;</span> FORCE)</span><br></pre></td></tr></table></figure>

<p>在多配置下会多出 ASan 选项。</p>
<hr>
<h2 id="6-5-常见编译选项变量"><a href="#6-5-常见编译选项变量" class="headerlink" title="6.5 常见编译选项变量"></a>6.5 常见编译选项变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_C_FLAGS_&lt;CONFIG&gt;</code></td>
<td>C 语言特定编译选项</td>
</tr>
<tr>
<td><code>CMAKE_CXX_FLAGS_&lt;CONFIG&gt;</code></td>
<td>C++ 编译选项</td>
</tr>
<tr>
<td><code>&lt;LANG&gt;_COMPILER_LAUNCHER</code></td>
<td>包装器（ccache, distcc）</td>
</tr>
<tr>
<td><code>CMAKE_EXE_LINKER_FLAGS_&lt;CONFIG&gt;</code></td>
<td>链接器参数</td>
</tr>
<tr>
<td><code>CMAKE_&lt;LANG&gt;_FLAGS_INIT</code></td>
<td>默认初始值</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_DEBUG <span class="string">&quot;-g -O0&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_FLAGS_RELEASE <span class="string">&quot;-O3 -DNDEBUG&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-6-针对目标的生成器表达式"><a href="#6-6-针对目标的生成器表达式" class="headerlink" title="6.6 针对目标的生成器表达式"></a>6.6 针对目标的生成器表达式</h2><p>CMake 提供带 <code>$&lt;CONFIG:...&gt;</code> 的表达式区分配置：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(app PRIVATE</span><br><span class="line">  $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_MODE&gt;</span><br><span class="line">  $&lt;$&lt;CONFIG:Release&gt;:NDEBUG&gt;)</span><br></pre></td></tr></table></figure>

<p>或路径区分：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_directories</span>(app PRIVATE</span><br><span class="line">  $&lt;$&lt;CONFIG:Debug&gt;:<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/lib/Debug&gt;</span><br><span class="line">  $&lt;$&lt;CONFIG:Release&gt;:<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/lib/Release&gt;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-7-跨平台变量与宏"><a href="#6-7-跨平台变量与宏" class="headerlink" title="6.7 跨平台变量与宏"></a>6.7 跨平台变量与宏</h2><table>
<thead>
<tr>
<th>平台宏</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>WIN32</code></td>
<td>Windows</td>
</tr>
<tr>
<td><code>UNIX</code> (含 macOS, Linux)</td>
<td>类 Unix</td>
</tr>
<tr>
<td><code>APPLE</code></td>
<td>macOS</td>
</tr>
<tr>
<td><code>MSVC</code></td>
<td>Microsoft VC 编译器</td>
</tr>
<tr>
<td><code>MINGW</code></td>
<td>MinGW</td>
</tr>
<tr>
<td><code>CMAKE_SYSTEM_NAME</code></td>
<td>操作系统名称</td>
</tr>
<tr>
<td><code>CMAKE_HOST_SYSTEM_NAME</code></td>
<td>主机系统名称</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">  <span class="keyword">add_definitions</span>(-DPLATFORM_WINDOWS)</span><br><span class="line"><span class="keyword">elseif</span>(APPLE)</span><br><span class="line">  <span class="keyword">add_definitions</span>(-DPLATFORM_MAC)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-8-多平台编译器适配"><a href="#6-8-多平台编译器适配" class="headerlink" title="6.8 多平台编译器适配"></a>6.8 多平台编译器适配</h2><p>根据编译器设置选项：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(MSVC)</span><br><span class="line">  <span class="keyword">target_compile_options</span>(app PRIVATE /W4 /permissive-)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">target_compile_options</span>(app PRIVATE -Wall -Wextra -pedantic)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>善用 <code>generator expressions</code> 区分快捷。</p>
<hr>
<h2 id="6-9-跨编译（Cross-Compilation）简述"><a href="#6-9-跨编译（Cross-Compilation）简述" class="headerlink" title="6.9 跨编译（Cross Compilation）简述"></a>6.9 跨编译（Cross Compilation）简述</h2><p>跨编译主要依靠“<strong>Toolchain 文件</strong>”：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=armgcc-toolchain.cmake -DCMAKE_BUILD_TYPE=Release ..</span><br></pre></td></tr></table></figure>

<p>示例 toolchain 文件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_NAME Linux)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_SYSTEM_PROCESSOR arm)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_COMPILER arm-linux-gnueabihf-gcc)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_COMPILER arm-linux-gnueabihf-g++)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_FIND_ROOT_PATH /opt/arm-sysroot)</span><br></pre></td></tr></table></figure>
<p>CMake 据此调整系统搜索路径与交叉工具链。  </p>
<hr>
<h2 id="6-10-默认输出目录按配置分类"><a href="#6-10-默认输出目录按配置分类" class="headerlink" title="6.10 默认输出目录按配置分类"></a>6.10 默认输出目录按配置分类</h2><p>推荐写法：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(OUTPUTCONFIG IN LISTS CMAKE_CONFIGURATION_TYPES)</span><br><span class="line">  <span class="keyword">string</span>(TOUPPER <span class="variable">$&#123;OUTPUTCONFIG&#125;</span> OUTPUTCONFIG)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY_<span class="variable">$&#123;OUTPUTCONFIG&#125;</span> <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/bin/$&#123;OUTPUTCONFIG&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY_<span class="variable">$&#123;OUTPUTCONFIG&#125;</span> <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib/$&#123;OUTPUTCONFIG&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY_<span class="variable">$&#123;OUTPUTCONFIG&#125;</span> <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;/lib/$&#123;OUTPUTCONFIG&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>
<p>这样 Debug&#x2F;Release 便会分目录保存。</p>
<hr>
<h2 id="6-11-多平台策略经验总结"><a href="#6-11-多平台策略经验总结" class="headerlink" title="6.11 多平台策略经验总结"></a>6.11 多平台策略经验总结</h2><p>1️⃣ <strong>不滥用 if(PLATFORM)</strong><br>尽量放入单独 cmake 模块文件。<br>例如 <code>platform/windows.cmake</code>、<code>platform/linux.cmake</code>。  </p>
<p>2️⃣ <em><em>使用 target_</em> 属性接口化</em>*<br>而非直接全局设置 CMAKE_CXX_FLAGS。  </p>
<p>3️⃣ <strong>确保跨编译工具链自洽</strong><br>不要在 toolchain 里硬编码 host 路径；保持干净的 sysroot。  </p>
<p>4️⃣ <strong>利用缓存变量区分环境</strong><br>如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=... -DPLATFORM_RPI=ON</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-12-章节小结"><a href="#6-12-章节小结" class="headerlink" title="6.12 章节小结"></a>6.12 章节小结</h2><p>✅ 本章你已经掌握：  </p>
<ul>
<li>单配置 vs 多配置 构建机制  </li>
<li><code>CMAKE_BUILD_TYPE</code> 的意义  </li>
<li>各个类型的优化与宏控制  </li>
<li>在 target 层使用 generator 表达式实现多配置差异  </li>
<li>用 toolchain 文件跨平台构建工程  </li>
<li>多平台编译器选项与输出目录规范</li>
</ul>
<hr>
<hr>
<h1 id="🔧-第-7-章-自定义命令-与-自定义目标：add-custom-command-add-custom-target"><a href="#🔧-第-7-章-自定义命令-与-自定义目标：add-custom-command-add-custom-target" class="headerlink" title="🔧 第 7 章 | 自定义命令 与 自定义目标：add_custom_command() &amp; add_custom_target()"></a>🔧 第 7 章 | 自定义命令 与 自定义目标：add_custom_command() &amp; add_custom_target()</h1><hr>
<h2 id="7-1-核心概念"><a href="#7-1-核心概念" class="headerlink" title="7.1 核心概念"></a>7.1 核心概念</h2><blockquote>
<p><strong>CMake 不只会编译代码</strong>，它同样能驱动各种外部命令、代码生成、打包、复制、清理等任务。<br>这就依赖于 <code>add_custom_command()</code> 和 <code>add_custom_target()</code>。  </p>
</blockquote>
<ul>
<li><strong><code>add_custom_command()</code></strong> → 定制生成规则（产生文件）  </li>
<li><strong><code>add_custom_target()</code></strong> → 定义独立目标（不一定生成文件）</li>
</ul>
<hr>
<h2 id="7-2-add-custom-command-生成型命令"><a href="#7-2-add-custom-command-生成型命令" class="headerlink" title="7.2 add_custom_command() 生成型命令"></a>7.2 add_custom_command() 生成型命令</h2><p>语法一（输出文件）：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT  generated.cpp</span><br><span class="line">  <span class="keyword">COMMAND</span> python3 gen.py input.idl -o generated.cpp</span><br><span class="line">  DEPENDS input.idl gen.py</span><br><span class="line">  COMMENT <span class="string">&quot;生成代码文件 generated.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>OUTPUT</code></td>
<td>执行命令后生成的文件</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>具体执行的命令</td>
</tr>
<tr>
<td><code>DEPENDS</code></td>
<td>文件或目标依赖</td>
</tr>
<tr>
<td><code>WORKING_DIRECTORY</code></td>
<td>运行目录</td>
</tr>
<tr>
<td><code>COMMENT</code></td>
<td>日志显示</td>
</tr>
<tr>
<td><code>BYPRODUCTS</code></td>
<td>除 OUTPUT 外产生的其他文件</td>
</tr>
<tr>
<td><code>VERBATIM</code></td>
<td>自动安全转义字符串</td>
</tr>
</tbody></table>
<p>🔹 执行机制：当 CMake 发现 <code>OUTPUT</code> 缺失或 <code>DEPENDS</code> 更新时，该命令触发。</p>
<hr>
<h3 id="与-target-建立关系"><a href="#与-target-建立关系" class="headerlink" title="与 target 建立关系"></a>与 target 建立关系</h3><p>上面只是规则，要让它生效，必须让某目标依赖它：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(app main.cpp generated.cpp)</span><br><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT generated.cpp</span><br><span class="line">  <span class="keyword">COMMAND</span> python3 gen.py input.idl -o generated.cpp</span><br><span class="line">  DEPENDS input.idl gen.py</span><br><span class="line">  COMMENT <span class="string">&quot;生成接口文件&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>CMake 自动在编译 app 前执行代码生成。</p>
<p>若独立生成多个文件可组合：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT a.h b.h</span><br><span class="line">  <span class="keyword">COMMAND</span> gen_headers.sh <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span></span><br><span class="line">  DEPENDS defs.json</span><br><span class="line">  BYPRODUCTS temp.log)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-3-add-custom-target-自定义目标"><a href="#7-3-add-custom-target-自定义目标" class="headerlink" title="7.3 add_custom_target() 自定义目标"></a>7.3 add_custom_target() 自定义目标</h2><p>语法：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(&lt;name&gt; [ALL]</span><br><span class="line">  <span class="keyword">COMMAND</span> &lt;cmd1&gt; [ARGS...]</span><br><span class="line">  DEPENDS &lt;other_target(s)&gt; &lt;<span class="keyword">file</span>(s)&gt;</span><br><span class="line">  COMMENT <span class="string">&quot;some text&quot;</span>)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>关键字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ALL</code></td>
<td>编入默认 <code>all</code> 目标</td>
</tr>
<tr>
<td><code>COMMAND</code></td>
<td>可多条</td>
</tr>
<tr>
<td><code>DEPENDS</code></td>
<td>可是文件或目标</td>
</tr>
<tr>
<td><code>WORKING_DIRECTORY</code></td>
<td>执行位置</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(run ALL</span><br><span class="line">  <span class="keyword">COMMAND</span> app</span><br><span class="line">  DEPENDS app</span><br><span class="line">  COMMENT <span class="string">&quot;执行应用程序&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行：<code>cmake --build . --target run</code></p>
<hr>
<h2 id="7-4-add-custom-target-VS-add-custom-command"><a href="#7-4-add-custom-target-VS-add-custom-command" class="headerlink" title="7.4 add_custom_target VS add_custom_command"></a>7.4 add_custom_target VS add_custom_command</h2><table>
<thead>
<tr>
<th>功能差异</th>
<th>add_custom_command</th>
<th>add_custom_target</th>
</tr>
</thead>
<tbody><tr>
<td>是否生成文件</td>
<td>✅</td>
<td>❌</td>
</tr>
<tr>
<td>能否依赖于目标</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td>可否加入默认编译</td>
<td>否（需被其他目标依赖）</td>
<td>可选 ALL</td>
</tr>
<tr>
<td>常见用途</td>
<td>代码生成、资源拷贝等</td>
<td>运行脚本、测试、打包</td>
</tr>
</tbody></table>
<p>组合使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(OUTPUT generated.h</span><br><span class="line">  <span class="keyword">COMMAND</span> gen_header tool.idl -o generated.h</span><br><span class="line">  DEPENDS tool.idl)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_custom_target</span>(generate ALL</span><br><span class="line">  DEPENDS generated.h)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-5-典型用途示例"><a href="#7-5-典型用途示例" class="headerlink" title="7.5 典型用途示例"></a>7.5 典型用途示例</h2><h3 id="1-资源拷贝"><a href="#1-资源拷贝" class="headerlink" title="(1) 资源拷贝"></a>(1) 资源拷贝</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  <span class="keyword">TARGET</span> app POST_BUILD</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy</span><br><span class="line">          <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/config.json</span><br><span class="line">          $&lt;TARGET_FILE_DIR:app&gt;/config.json)</span><br></pre></td></tr></table></figure>

<p>💬 语法 2 ：当命令与已有目标关联时，可以省去 OUTPUT。</p>
<hr>
<h3 id="2-代码生成-→-Protobuf"><a href="#2-代码生成-→-Protobuf" class="headerlink" title="(2) 代码生成 → Protobuf"></a>(2) 代码生成 → Protobuf</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT address.pb.cc address.pb.h</span><br><span class="line">  <span class="keyword">COMMAND</span> protoc --cpp_out=. <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/address.proto</span><br><span class="line">  DEPENDS <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/address.proto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_library</span>(proto address.pb.cc)</span><br><span class="line"><span class="keyword">target_include_directories</span>(proto PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="3-打包目标"><a href="#3-打包目标" class="headerlink" title="(3) 打包目标"></a>(3) 打包目标</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(package_zip ALL</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E <span class="keyword">make_directory</span> <span class="variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/dist</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E tar <span class="string">&quot;cfv&quot;</span> dist/app.zip --format=zip</span><br><span class="line">          app.exe config.json</span><br><span class="line">  COMMENT <span class="string">&quot;打包项目&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-6-CMake-内置辅助命令"><a href="#7-6-CMake-内置辅助命令" class="headerlink" title="7.6 CMake 内置辅助命令"></a>7.6 CMake 内置辅助命令</h2><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmake -E copy</code></td>
<td>复制文件</td>
</tr>
<tr>
<td><code>cmake -E remove</code></td>
<td>删除文件</td>
</tr>
<tr>
<td><code>cmake -E tar</code></td>
<td>打包&#x2F;解包</td>
</tr>
<tr>
<td><code>cmake -E echo</code></td>
<td>打印信息</td>
</tr>
<tr>
<td><code>cmake -E env</code></td>
<td>设置临时环境变量</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(print_env</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env MY_VAR=<span class="number">123</span> bash -c <span class="string">&quot;echo $MY_VAR&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-7-构建事件与阶段"><a href="#7-7-构建事件与阶段" class="headerlink" title="7.7 构建事件与阶段"></a>7.7 构建事件与阶段</h2><p>CMake 支持在目标的不同阶段插入命令：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  <span class="keyword">TARGET</span> app</span><br><span class="line">  PRE_BUILD   <span class="keyword">COMMAND</span> &lt;cmd&gt;  <span class="comment"># Windows only</span></span><br><span class="line">  PRE_LINK    <span class="keyword">COMMAND</span> &lt;cmd&gt;</span><br><span class="line">  POST_BUILD  <span class="keyword">COMMAND</span> &lt;cmd&gt;)</span><br></pre></td></tr></table></figure>

<p>Linux 下通常使用 POST_BUILD 即可。</p>
<hr>
<h2 id="7-8-自定义清理与格式化"><a href="#7-8-自定义清理与格式化" class="headerlink" title="7.8 自定义清理与格式化"></a>7.8 自定义清理与格式化</h2><h3 id="清理生成文件："><a href="#清理生成文件：" class="headerlink" title="清理生成文件："></a>清理生成文件：</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(clean_gen</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E rm -f generated.*</span><br><span class="line">  COMMENT <span class="string">&quot;清理生成的中间文件&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="一键格式化源代码："><a href="#一键格式化源代码：" class="headerlink" title="一键格式化源代码："></a>一键格式化源代码：</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_target</span>(format</span><br><span class="line">  <span class="keyword">COMMAND</span> clang-format -i <span class="variable">$&#123;ALL_SOURCE_FILES&#125;</span></span><br><span class="line">  COMMENT <span class="string">&quot;源代码格式化&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="7-9-综合实例：集成自动代码生成"><a href="#7-9-综合实例：集成自动代码生成" class="headerlink" title="7.9 综合实例：集成自动代码生成"></a>7.9 综合实例：集成自动代码生成</h2><p>目录结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tool/</span><br><span class="line">├─ gen.py</span><br><span class="line">├─ input.msg</span><br><span class="line">└─ main.cpp</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  OUTPUT <span class="keyword">message</span>.hpp</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;Python3_EXECUTABLE&#125;</span> <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/gen.py <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>/input.msg &gt; <span class="keyword">message</span>.hpp</span><br><span class="line">  DEPENDS gen.py input.msg</span><br><span class="line">  COMMENT <span class="string">&quot;生成 message.hpp&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(tool main.cpp <span class="keyword">message</span>.hpp)</span><br></pre></td></tr></table></figure>

<p>执行构建时，如果输入有更新，CMake 会自动重新执行 gen.py。</p>
<hr>
<h2 id="7-10-章节小结"><a href="#7-10-章节小结" class="headerlink" title="7.10 章节小结"></a>7.10 章节小结</h2><p>✅ 你已掌握：</p>
<ul>
<li><code>add_custom_command()</code> 用于生成文件或附加命令  </li>
<li><code>add_custom_target()</code> 用于定义逻辑目标  </li>
<li>如何在 目标 不同阶段 执行命令（PRE&#x2F;POST_BUILD）  </li>
<li>利用 cmake 内置执行命令 <code>cmake -E</code> 完成通用任务  </li>
<li>自定义格式化、打包、清理、代码生成任务实践</li>
</ul>
<hr>
<hr>
<h1 id="🧪-第-8-章-测试与持续集成：CTest-与-CDash-使用"><a href="#🧪-第-8-章-测试与持续集成：CTest-与-CDash-使用" class="headerlink" title="🧪 第 8 章 | 测试与持续集成：CTest 与 CDash 使用"></a>🧪 第 8 章 | 测试与持续集成：CTest 与 CDash 使用</h1><hr>
<h2 id="8-1-CMake-与-CTest-的关系"><a href="#8-1-CMake-与-CTest-的关系" class="headerlink" title="8.1 CMake 与 CTest 的关系"></a>8.1 CMake 与 CTest 的关系</h2><p>CMake 并不仅生成构建系统，还包含自己的测试驱动框架 —— <strong>CTest</strong>。<br>它允许你在编译后自动执行单元测试、性能测试，并把结果提交给 CDash 仪表盘。  </p>
<blockquote>
<p>✅ 核心优势  </p>
<ul>
<li>跨平台测试入口一致：<code>ctest</code>  </li>
<li>可与 CTest 命令、CTestConfig.cmake、CDash 无缝集成  </li>
<li>同时支持 GoogleTest、Catch2、doctest 等框架</li>
</ul>
</blockquote>
<hr>
<h2 id="8-2-启用测试"><a href="#8-2-启用测试" class="headerlink" title="8.2 启用测试"></a>8.2 启用测试</h2><p>在顶层 CMakeLists.txt 内加入：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enable_testing</span>()</span><br></pre></td></tr></table></figure>
<p>此命会自动生成 CTestTestfile.cmake，<br>并允许使用 <code>add_test()</code> 添加测试目标。  </p>
<hr>
<h2 id="8-3-add-test-基础语法"><a href="#8-3-add-test-基础语法" class="headerlink" title="8.3 add_test() 基础语法"></a>8.3 add_test() 基础语法</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME &lt;test_name&gt;</span><br><span class="line">         <span class="keyword">COMMAND</span> &lt;executable&gt; [args...])</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(mytests test_main.cpp)</span><br><span class="line"><span class="keyword">add_test</span>(NAME basic <span class="keyword">COMMAND</span> mytests)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>之后即可在构建目录下运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctest</span><br><span class="line">ctest -V   <span class="comment"># verbose 输出</span></span><br><span class="line">ctest -R basic  <span class="comment"># 按名称筛选</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr>
<h2 id="8-4-test-属性与配置"><a href="#8-4-test-属性与配置" class="headerlink" title="8.4 test 属性与配置"></a>8.4 test 属性与配置</h2><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WORKING_DIRECTORY</td>
<td>更改测试执行目录</td>
</tr>
<tr>
<td>TIMEOUT</td>
<td>指定超时(秒)</td>
</tr>
<tr>
<td>ENVIRONMENT</td>
<td>设置环境变量</td>
</tr>
<tr>
<td>LABELS</td>
<td>添加标签分类</td>
</tr>
<tr>
<td>DEPENDS</td>
<td>依赖其他测试完成</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME net_ping</span><br><span class="line">  <span class="keyword">COMMAND</span> ping_app --url=https://example.com)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(net_ping PROPERTIES</span><br><span class="line">  TIMEOUT <span class="number">15</span></span><br><span class="line">  LABELS <span class="string">&quot;network;integration&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-5-与-GoogleTest-集成"><a href="#8-5-与-GoogleTest-集成" class="headerlink" title="8.5 与 GoogleTest 集成"></a>8.5 与 GoogleTest 集成</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(</span><br><span class="line">  googletest</span><br><span class="line">  GIT_REPOSITORY https://github.com/google/googletest.git</span><br><span class="line">  GIT_TAG release-<span class="number">1.14</span>.<span class="number">0</span>)</span><br><span class="line">FetchContent_MakeAvailable(googletest)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(unit_tests test_math.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(unit_tests PRIVATE GTest::gtest_main)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(GoogleTest)</span><br><span class="line">gtest_discover_tests(unit_tests)</span><br></pre></td></tr></table></figure>

<p>执行：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctest -V</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>gtest_discover_tests()</code> 会在配置时自动枚举 TEST() 宏生成的子测试。</p>
</blockquote>
<hr>
<h2 id="8-6-输出与日志"><a href="#8-6-输出与日志" class="headerlink" title="8.6 输出与日志"></a>8.6 输出与日志</h2><table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>-V</code></td>
<td>详细信息</td>
</tr>
<tr>
<td><code>-N</code></td>
<td>只列出而不执行</td>
</tr>
<tr>
<td><code>--output-on-failure</code></td>
<td>失败时输出详情</td>
</tr>
<tr>
<td><code>--repeat until-fail:3</code></td>
<td>重试失败测试</td>
</tr>
<tr>
<td><code>-R pattern</code></td>
<td>按名称正则筛选</td>
</tr>
</tbody></table>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctest --output-on-failure -R net</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-7-分组与标签管理"><a href="#8-7-分组与标签管理" class="headerlink" title="8.7 分组与标签管理"></a>8.7 分组与标签管理</h2><p>可通过标签控制测试集合：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set_tests_properties</span>(api_test PROPERTIES LABELS <span class="string">&quot;integration&quot;</span>)</span><br><span class="line"><span class="keyword">set_tests_properties</span>(math_test PROPERTIES LABELS <span class="string">&quot;unit&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行分组：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctest -L unit</span><br></pre></td></tr></table></figure>

<p>或排除：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctest -LE integration</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="8-8-CTest-配置文件"><a href="#8-8-CTest-配置文件" class="headerlink" title="8.8 CTest 配置文件"></a>8.8 CTest 配置文件</h2><p>在项目根目录创建 <code>CTestConfig.cmake</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CTEST_PROJECT_NAME <span class="string">&quot;MyProj&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_NIGHTLY_START_TIME <span class="string">&quot;00:00:00 UTC&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_METHOD <span class="string">&quot;https&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE <span class="string">&quot;cdash.myserver.com&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_LOCATION <span class="string">&quot;/submit.php?project=MyProj&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CTEST_DROP_SITE_CDASH <span class="keyword">TRUE</span>)</span><br></pre></td></tr></table></figure>

<p>该文件为 CDash 上传配置提供默认值。</p>
<hr>
<h2 id="8-9-CTest-驱动脚本模式"><a href="#8-9-CTest-驱动脚本模式" class="headerlink" title="8.9 CTest 驱动脚本模式"></a>8.9 CTest 驱动脚本模式</h2><blockquote>
<p>通过 <code>ctest -S script.cmake</code> 运行可自动完成：配置 → 编译 → 测试 → 上传。  </p>
</blockquote>
<p>示例 <code>script.cmake</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ctest_start</span>(Experimental)</span><br><span class="line"><span class="keyword">ctest_configure</span>(BUILD <span class="string">&quot;$&#123;CMAKE_BINARY_DIR&#125;&quot;</span> SOURCE <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">ctest_build</span>()</span><br><span class="line"><span class="keyword">ctest_test</span>(REPORT_FORMAT xml OUTPUT_JUNIT results.xml)</span><br><span class="line"><span class="keyword">ctest_submit</span>()</span><br></pre></td></tr></table></figure>

<p>可配合 cron 或 CI&#x2F;CD 定期执行。</p>
<hr>
<h2 id="8-10-CDash-仪表盘简介"><a href="#8-10-CDash-仪表盘简介" class="headerlink" title="8.10 CDash 仪表盘简介"></a>8.10 CDash 仪表盘简介</h2><p><strong>CDash</strong> 是 Kitware 提供的 Web 测试结果展示平台。  </p>
<p>你可以：</p>
<ul>
<li>聚合各个构建机的 Build&#x2F;Test 结果</li>
<li>可视化性能&#x2F;覆盖率变化</li>
<li>追踪回归</li>
</ul>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8081:80 kitware/cdash</span><br></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:8081/">http://localhost:8081</a><br>然后在 CTestConfig.cmake 中填写相应的 DROP 地址。</p>
<hr>
<h2 id="8-11-测试覆盖率与内存检查"><a href="#8-11-测试覆盖率与内存检查" class="headerlink" title="8.11 测试覆盖率与内存检查"></a>8.11 测试覆盖率与内存检查</h2><h3 id="覆盖率"><a href="#覆盖率" class="headerlink" title="覆盖率"></a>覆盖率</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DENABLE_COVERAGE=ON ..</span><br><span class="line">make coverage</span><br></pre></td></tr></table></figure>
<p>结合工具如 <code>gcovr</code> &#x2F; <code>llvm-cov</code>。  </p>
<h3 id="内存泄漏检查"><a href="#内存泄漏检查" class="headerlink" title="内存泄漏检查"></a>内存泄漏检查</h3><p>在测试命令中加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_test</span>(NAME memcheck</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E env ASAN_OPTIONS=detect_leaks=<span class="number">1</span> ctest)</span><br></pre></td></tr></table></figure>
<p>或使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctest -T MemCheck</span><br></pre></td></tr></table></figure>
<p>CMake 会自动在测试下运行 Valgrind 或 Dr.Memory。</p>
<hr>
<h2 id="8-12-与-CI-系统结合"><a href="#8-12-与-CI-系统结合" class="headerlink" title="8.12 与 CI 系统结合"></a>8.12 与 CI 系统结合</h2><p>常见方式：<br>1️⃣ <strong>GitHub Actions</strong><br>   <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">run:</span> <span class="string">cmake</span> <span class="string">-S</span> <span class="string">.</span> <span class="string">-B</span> <span class="string">build</span> <span class="string">-DCMAKE_BUILD_TYPE=Release</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">run:</span> <span class="string">cmake</span> <span class="string">--build</span> <span class="string">build</span> <span class="string">-j</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">run:</span> <span class="string">ctest</span> <span class="string">--test-dir</span> <span class="string">build</span> <span class="string">--output-on-failure</span></span><br></pre></td></tr></table></figure></p>
<p>2️⃣ <strong>GitLab CI</strong><br>   <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cmake</span> <span class="string">-S</span> <span class="string">.</span> <span class="string">-B</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cmake</span> <span class="string">--build</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">build</span> <span class="string">&amp;&amp;</span> <span class="string">ctest</span> <span class="string">-V</span></span><br></pre></td></tr></table></figure></p>
<p>3️⃣ <strong>Jenkins &#x2F; TeamCity</strong></p>
<blockquote>
<p>可直接执行 ctest 或调用 CTest 脚本模式。  </p>
</blockquote>
<hr>
<h2 id="8-13-章节小结"><a href="#8-13-章节小结" class="headerlink" title="8.13 章节小结"></a>8.13 章节小结</h2><p>✅ 你现在会：</p>
<ul>
<li>使用 <code>enable_testing()</code> 启用测试  </li>
<li>借助 <code>add_test()</code> 添加单元测试  </li>
<li>输出详细日志并分组管理  </li>
<li>集成 GoogleTest 框架  </li>
<li>通过 CTest 脚本 + CDash 形成完整仪表盘  </li>
<li>将测试接入 CI&#x2F;CD 平台</li>
</ul>
<hr>
<hr>
<h1 id="📦-第-9-章-安装、导出与复用：install-与-CMake-Package-Config"><a href="#📦-第-9-章-安装、导出与复用：install-与-CMake-Package-Config" class="headerlink" title="📦 第 9 章 | 安装、导出与复用：install() 与 CMake Package Config"></a>📦 第 9 章 | 安装、导出与复用：install() 与 CMake Package Config</h1><hr>
<h2 id="9-1-安装的意义"><a href="#9-1-安装的意义" class="headerlink" title="9.1 安装的意义"></a>9.1 安装的意义</h2><p>CMake 可以将编译产物、头文件、配置、资源统一打包到安装目录。<br>这不仅方便部署，还能让别的项目通过 <code>find_package()</code> 直接复用你的库。  </p>
<p><strong>安装流程</strong>  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --install &lt;build_dir&gt; [--prefix &lt;path&gt;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>默认前缀为 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;</code>，<br>Linux 通常 <code>/usr/local</code>，Windows 为 <code>C:/Program Files/&lt;proj&gt;</code>。</p>
</blockquote>
<hr>
<h2 id="9-2-install-核心语法"><a href="#9-2-install-核心语法" class="headerlink" title="9.2 install() 核心语法"></a>9.2 install() 核心语法</h2><p>CMake 的 <code>install()</code> 命令支持安装“目标”、“文件”、“目录”和“脚本”。  </p>
<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>TARGETS</td>
<td><code>install(TARGETS mylib)</code></td>
<td>可执行&#x2F;库目标</td>
</tr>
<tr>
<td>FILES</td>
<td><code>install(FILES a.h b.h DESTINATION include)</code></td>
<td>纯文件</td>
</tr>
<tr>
<td>DIRECTORY</td>
<td><code>install(DIRECTORY include/ DESTINATION include)</code></td>
<td>整个目录</td>
</tr>
<tr>
<td>PROGRAMS</td>
<td><code>install(PROGRAMS script.sh DESTINATION bin)</code></td>
<td>可执行脚本</td>
</tr>
<tr>
<td>SCRIPT &#x2F; CODE</td>
<td>用于在安装执行 CMake 代码</td>
<td></td>
</tr>
</tbody></table>
<hr>
<h2 id="9-3-安装可执行与库"><a href="#9-3-安装可执行与库" class="headerlink" title="9.3 安装可执行与库"></a>9.3 安装可执行与库</h2><p>最常见写法：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br><span class="line"><span class="keyword">add_library</span>(mathlib <span class="keyword">math</span>.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(TARGETS app mathlib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  ARCHIVE DESTINATION lib/static)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>- RUNTIME → 可执行文件<br>- LIBRARY → 动态库 (.so&#x2F;.dylib)<br>- ARCHIVE → 静态库 (.a&#x2F;.lib)  </p>
</blockquote>
<hr>
<h2 id="9-4-安装头文件"><a href="#9-4-安装头文件" class="headerlink" title="9.4 安装头文件"></a>9.4 安装头文件</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>/</span><br><span class="line">  DESTINATION <span class="keyword">include</span></span><br><span class="line">  FILES_MATCHING PATTERN <span class="string">&quot;*.h&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>或直接列表式：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES <span class="keyword">math</span>.h util.h DESTINATION <span class="keyword">include</span>/mylib)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-5-CMAKE-INSTALL-PREFIX-修改"><a href="#9-5-CMAKE-INSTALL-PREFIX-修改" class="headerlink" title="9.5 CMAKE_INSTALL_PREFIX 修改"></a>9.5 CMAKE_INSTALL_PREFIX 修改</h2><p>配置时指定：  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_INSTALL_PREFIX=/opt/mylib ..</span><br><span class="line">cmake --install build</span><br></pre></td></tr></table></figure>

<p>也可在 CMakeLists 中设置默认：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_INSTALL_PREFIX <span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/dist&quot;</span> CACHE PATH <span class="string">&quot;&quot;</span> FORCE)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-6-生成安装包目录结构示例"><a href="#9-6-生成安装包目录结构示例" class="headerlink" title="9.6 生成安装包目录结构示例"></a>9.6 生成安装包目录结构示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dist/</span><br><span class="line"> ├─ bin/</span><br><span class="line"> │   └─ app</span><br><span class="line"> ├─ lib/</span><br><span class="line"> │   ├─ libmathlib.so</span><br><span class="line"> │   └─ cmake/mylib/MyLibConfig.cmake</span><br><span class="line"> ├─ include/</span><br><span class="line"> │   └─ mylib/</span><br><span class="line"> │       └─ math.h</span><br><span class="line"> └─ share/doc/</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-7-导出目标与重用"><a href="#9-7-导出目标与重用" class="headerlink" title="9.7 导出目标与重用"></a>9.7 导出目标与重用</h2><p>为了让别的项目 <code>find_package(MyLib)</code> 生效，<br>需要导出目标和配置文件。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS mathlib</span><br><span class="line">  <span class="keyword">EXPORT</span> MyLibTargets</span><br><span class="line">  DESTINATION lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyLibTargets</span><br><span class="line">  <span class="keyword">FILE</span> MyLibTargets.cmake</span><br><span class="line">  NAMESPACE MyLib::</span><br><span class="line">  DESTINATION lib/cmake/MyLib)</span><br></pre></td></tr></table></figure>

<p>这样别的项目可写：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyLib REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE MyLib::mathlib)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-8-Config-Package-文件"><a href="#9-8-Config-Package-文件" class="headerlink" title="9.8 Config Package 文件"></a>9.8 Config Package 文件</h2><p>生成 <code>MyLibConfig.cmake</code> 和 <code>MyLibConfigVersion.cmake</code>，<br>用于描述库版本与依赖。&#96;&#96;&#96;cmake<br>include(CMakePackageConfigHelpers)</p>
<p>write_basic_package_version_file(<br>  “${CMAKE_CURRENT_BINARY_DIR}&#x2F;MyLibConfigVersion.cmake”<br>  VERSION ${PROJECT_VERSION}<br>  COMPATIBILITY SameMajorVersion)</p>
<p>configure_package_config_file(<br>  “${CMAKE_CURRENT_SOURCE_DIR}&#x2F;cmake&#x2F;MyLibConfig.cmake.in”<br>  “${CMAKE_CURRENT_BINARY_DIR}&#x2F;MyLibConfig.cmake”<br>  INSTALL_DESTINATION lib&#x2F;cmake&#x2F;MyLib)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">模板 `MyLibConfig.cmake.in`：</span><br><span class="line">```cmake</span><br><span class="line">@PACKAGE_INIT@</span><br><span class="line">include(&quot;$&#123;CMAKE_CURRENT_LIST_DIR&#125;/MyLibTargets.cmake&quot;)</span><br></pre></td></tr></table></figure>

<p>之后一起安装：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyLibConfig.cmake&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyLibConfigVersion.cmake&quot;</span></span><br><span class="line">  DESTINATION lib/cmake/MyLib)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-9-导出构建目录（非安装模式）"><a href="#9-9-导出构建目录（非安装模式）" class="headerlink" title="9.9 导出构建目录（非安装模式）"></a>9.9 导出构建目录（非安装模式）</h2><p>在开发时可直接导出构建树供临时使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span>(<span class="keyword">EXPORT</span> MyLibTargets</span><br><span class="line">  <span class="keyword">FILE</span> <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY&#125;/MyLibTargets.cmake&quot;</span></span><br><span class="line">  NAMESPACE MyLib::)</span><br></pre></td></tr></table></figure>

<p>别的项目在本地可通过：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MyLib_DIR <span class="string">&quot;/path/to/build&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(MyLib REQUIRED)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-10-install-命令附带组件与条件"><a href="#9-10-install-命令附带组件与条件" class="headerlink" title="9.10 install 命令附带组件与条件"></a>9.10 install 命令附带组件与条件</h2><p>设置组件：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS app</span><br><span class="line">  COMPONENT runtime</span><br><span class="line">  DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(DIRECTORY docs/ DESTINATION share/doc COMPONENT doc)</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake --install build --component runtime</span><br></pre></td></tr></table></figure>

<p>条件安装：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(FILES config.win DESTINATION etc RENAME config.txt</span><br><span class="line">  CONFIGURATIONS Release)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="9-11-使用-CPack-生成打包文件"><a href="#9-11-使用-CPack-生成打包文件" class="headerlink" title="9.11 使用 CPack 生成打包文件"></a>9.11 使用 CPack 生成打包文件</h2><p>在项目中添加：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(InstallRequiredSystemLibraries)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_NAME <span class="string">&quot;MyLib&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VERSION <span class="string">&quot;1.0.0&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_GENERATOR <span class="string">&quot;ZIP;TGZ&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure>
<p>执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpack</span><br></pre></td></tr></table></figure>
<p>将自动把安装产物打包为 zip &#x2F; tar.gz 文件。  </p>
<hr>
<h2 id="9-12-章节小结"><a href="#9-12-章节小结" class="headerlink" title="9.12 章节小结"></a>9.12 章节小结</h2><p>✅ 你已掌握：<br>- 使用 install() 安装目标、文件、目录<br>- 通过 CMAKE_INSTALL_PREFIX 控制安装路径<br>- 导出 Targets 与 Config 文件供其他项目复用<br>- 使用 CPack 生成跨平台安装包  </p>
<hr>
<hr>
<h1 id="🧩-第-10-章-进阶项目结构与模块化设计：分层、宏与函数、Find-Module-编写"><a href="#🧩-第-10-章-进阶项目结构与模块化设计：分层、宏与函数、Find-Module-编写" class="headerlink" title="🧩 第 10 章 | 进阶项目结构与模块化设计：分层、宏与函数、Find Module 编写"></a>🧩 第 10 章 | 进阶项目结构与模块化设计：分层、宏与函数、Find Module 编写</h1><hr>
<h2 id="10-1-大型项目的典型结构"><a href="#10-1-大型项目的典型结构" class="headerlink" title="10.1 大型项目的典型结构"></a>10.1 大型项目的典型结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProject/</span><br><span class="line">├─ CMakeLists.txt        # 顶层：配置、全局选项</span><br><span class="line">├─ cmake/                # 自定义模块脚本</span><br><span class="line">│   ├─ FindXXX.cmake</span><br><span class="line">│   └─ Utils.cmake</span><br><span class="line">├─ src/</span><br><span class="line">│   ├─ CMakeLists.txt    # 库 / 可执行定义</span><br><span class="line">│   ├─ core/</span><br><span class="line">│   └─ ui/</span><br><span class="line">├─ include/</span><br><span class="line">│   └─ myproj/</span><br><span class="line">│       └─ *.h</span><br><span class="line">├─ tests/</span><br><span class="line">│   ├─ CMakeLists.txt</span><br><span class="line">│   └─ *.cpp</span><br><span class="line">└─ examples/</span><br><span class="line">    └─ CMakeLists.txt</span><br></pre></td></tr></table></figure>

<p><strong>层级思路：</strong></p>
<ol>
<li>顶层处理全局配置、选项、依赖；</li>
<li>下层模块通过 <code>add_library()</code> 或 <code>add_executable()</code> 定义；</li>
<li>使用 <code>option()</code> 控制可编译模块；</li>
<li>代码与头文件保持分离。</li>
</ol>
<hr>
<h2 id="10-2-层级-CMakeLists-txt-的协作"><a href="#10-2-层级-CMakeLists-txt-的协作" class="headerlink" title="10.2 层级 CMakeLists.txt 的协作"></a>10.2 层级 CMakeLists.txt 的协作</h2><p>每级在自己的 CMakeLists.txt 中定义局部逻辑，<br>然后在上层用 <code>add_subdirectory()</code> 加载。</p>
<p><strong>顶层示例：</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_TESTS <span class="string">&quot;Build tests&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_TESTS)</span><br><span class="line">  <span class="keyword">enable_testing</span>()</span><br><span class="line"> _subdirectory(tests)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(cmake/Utils.cmake)</span><br></pre></td></tr></table></figure>

<p><strong>子模块：</strong>  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(core core.cpp core.h)</span><br><span class="line"><span class="keyword">target_include_directories</span>(core PUBLIC <span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-3-模块化与接口封装"><a href="#10-3-模块化与接口封装" class="headerlink" title="10.3 模块化与接口封装"></a>10.3 模块化与接口封装</h2><p>推荐做法：<br>每个子模块构成自成体系的 library，<br>暴露目标名、包含路径、依赖。  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(ui ui.cpp ui.h)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(ui PUBLIC core Qt::Widgets)</span><br></pre></td></tr></table></figure>

<p>其他模块只需：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE ui)</span><br></pre></td></tr></table></figure>

<p>通过 <code>target_*</code> 接口管理依赖而非手工 include&#x2F;link，是现代 CMake 的关键。</p>
<hr>
<h2 id="10-4-自定义函数与宏"><a href="#10-4-自定义函数与宏" class="headerlink" title="10.4 自定义函数与宏"></a>10.4 自定义函数与宏</h2><p>CMake 支持 <code>function()</code> 与 <code>macro()</code> 定义可重用逻辑。  </p>
<table>
<thead>
<tr>
<th>区别</th>
<th>function</th>
<th>macro</th>
</tr>
</thead>
<tbody><tr>
<td>作用域</td>
<td>局部作用域（推荐）</td>
<td>扩展到调用处作用域</td>
</tr>
<tr>
<td>参数传递</td>
<td>复制</td>
<td>文本替换</td>
</tr>
</tbody></table>
<p>例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake/Utils.cmake</span></span><br><span class="line"><span class="keyword">function</span>(add_my_exec name)</span><br><span class="line">  <span class="keyword">add_executable</span>(<span class="variable">$&#123;name&#125;</span> <span class="variable">$&#123;ARGN&#125;</span>)</span><br><span class="line">  <span class="keyword">target_compile_features</span>(<span class="variable">$&#123;name&#125;</span> PRIVATE cxx_std_17)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<p>使用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(cmake/Utils.cmake)</span><br><span class="line">add_my_exec(app main.cpp)</span><br></pre></td></tr></table></figure>

<p>可简化重复模式并保持一致性。</p>
<hr>
<h2 id="10-5-跨子项目传递变量"><a href="#10-5-跨子项目传递变量" class="headerlink" title="10.5 跨子项目传递变量"></a>10.5 跨子项目传递变量</h2><p>若要在顶层控制子项目，可以利用 <code>CACHE</code> 变量或 <code>option()</code>。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(BUILD_UI <span class="keyword">ON</span> CACHE BOOL <span class="string">&quot;Build UI module&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>子项目就能检测 <code>BUILD_UI</code> 是否为 ON。</p>
<p>若想真正导出到其他 scope，可用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(VAR_NAME value PARENT_SCOPE)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-6-自定义模块路径"><a href="#10-6-自定义模块路径" class="headerlink" title="10.6 自定义模块路径"></a>10.6 自定义模块路径</h2><p>若想让 CMake 找到自定义的 FindXXX.cmake：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>这样执行 <code>find_package(XXX REQUIRED)</code> 时，会优先在该目录搜索。</p>
<hr>
<h2 id="10-7-Find-Module-文件结构"><a href="#10-7-Find-Module-文件结构" class="headerlink" title="10.7 Find Module 文件结构"></a>10.7 Find Module 文件结构</h2><p>Find 模块通常命名为 <strong>Find<Package>.cmake</strong>。<br>基本模板：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FindFoo.cmake</span></span><br><span class="line"><span class="keyword">find_path</span>(FOO_INCLUDE_DIR foo.h)</span><br><span class="line"><span class="keyword">find_library</span>(FOO_LIBRARY NAMES foo)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include</span>(FindPackageHandleStandardArgs)</span><br><span class="line">find_package_handle_standard_args(Foo</span><br><span class="line">  REQUIRED_VARSOO_LIBRARY FOO_INCLUDE_DIR)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(FOO_FOUND)</span><br><span class="line">  <span class="keyword">set</span>(FOO_LIBRARIES <span class="variable">$&#123;FOO_LIBRARY&#125;</span>)</span><br><span class="line">  <span class="keyword">set</span>(FOO_INCLUDE_DIRS <span class="variable">$&#123;FOO_INCLUDE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>项目中即可：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Foo REQUIRED)</span><br><span class="line"><span class="keyword">target_include_directories</span>(app PRIVATE <span class="variable">$&#123;FOO_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE <span class="variable">$&#123;FOO_LIBRARIES&#125;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-8-封装外部依赖"><a href="#10-8-封装外部依赖" class="headerlink" title="10.8 封装外部依赖"></a>10.8 封装外部依赖</h2><p>对于常见第三方库，例如 fmt、spdlog、OpenCV、Boost：  </p>
<ul>
<li><strong>优先使用官方 CMake 包</strong>  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(fmt CONFIG REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE fmt::fmt)</span><br></pre></td></tr></table></figure></li>
<li><strong>无官方包时使用 Find 模块</strong>  </li>
<li><strong>或者使用 FetchContent 直接嵌入源码</strong></li>
</ul>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(FetchContent)</span><br><span class="line">FetchContent_Declare(spdlog</span><br><span class="line">  GIT_REPOSITORY https://github.com/gabime/spdlog.git</span><br><span class="line">  GIT_TAG v1.<span class="number">13.0</span>)</span><br><span class="line">FetchContent_MakeAvailable(spdlog)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE spdlog::spdlog)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="10-9-条件编译与平台差异"><a href="#10-9-条件编译与平台差异" class="headerlink" title="10.9 条件编译与平台差异"></a>10.9 条件编译与平台差异</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(app PRIVATE PLATFORM_WINDOWS)</span><br><span class="line"><span class="keyword">elseif</span>(APPLE)</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(app PRIVATE PLATFORM_MACOS)</span><br><span class="line"><span class="keyword">else</span>()</span><br><span class="line">  <span class="keyword">target_compile_definitions</span>(app PRIVATE PLATFORM_LINUX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<p>- <code>WIN32</code>, <code>UNIX</code>, <code>APPLE</code>, <code>CMAKE_SYSTEM_NAME</code> 等变量用于判断系统；<br>- 可配合 generator expression 在编译时自动切换。</p>
<hr>
<h2 id="10-10-生成器表达式回顾"><a href="#10-10-生成器表达式回顾" class="headerlink" title="10.10 生成器表达式回顾"></a>10.10 生成器表达式回顾</h2><p><strong>生成器表达式</strong> <code>$&lt;...&gt;</code><br>可在配置时决定某个属性在不同条件下的值：  </p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_compile_definitions</span>(app PRIVATE</span><br><span class="line">  $&lt;$&lt;CONFIG:Debug&gt;:DEBUG_BUILD&gt;)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(app PRIVATE</span><br><span class="line">  $&lt;$&lt;PLATFORM_ID:Windows&gt;:ws2_32&gt;)</span><br></pre></td></tr></table></figure>

<p>这样统一管理多平台差异且保持文件整洁。</p>
<hr>
<h2 id="10-11-最佳实践总结"><a href="#10-11-最佳实践总结" class="headerlink" title="10.11 最佳实践总结"></a>10.11 最佳实践总结</h2><p>✅ <strong>模块原则</strong>  </p>
<ul>
<li>每个模块尽量独立（自定义头、源码、CMakeLists）  </li>
<li>在接口上暴露目标而非路径  </li>
<li>避免使用全局变量与全局 include_directories</li>
</ul>
<p>✅ <strong>函数封装</strong>  </p>
<ul>
<li>将重复规则抽象成函数  </li>
<li>尽量避免宏污染全局</li>
</ul>
<p>✅ <strong>依赖管理</strong>  </p>
<ul>
<li>优先 CONFIG 包 → Find 模块 → FetchContent  </li>
<li>自己的库要导出 Config 文件方便他人 find_package()</li>
</ul>
<p>✅ <strong>目录组织</strong>  </p>
<ul>
<li><code>cmake/</code> 放自定义脚本  </li>
<li><code>include/</code> 暴露头文件  </li>
<li><code>src/</code> 放实现  </li>
<li><code>tests/</code>、<code>examples/</code> 清晰分层</li>
</ul>
<hr>
<h2 id="10-12-整门课程回顾-🙌"><a href="#10-12-整门课程回顾-🙌" class="headerlink" title="10.12 整门课程回顾 🙌"></a>10.12 整门课程回顾 🙌</h2><table>
<thead>
<tr>
<th>章节</th>
<th>核心内容</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>CMake 初体验</td>
</tr>
<tr>
<td>2</td>
<td>基本命令与变量</td>
</tr>
<tr>
<td>3</td>
<td>目标与依赖管理</td>
</tr>
<tr>
<td>4</td>
<td>编译选项与特性控制</td>
</tr>
<tr>
<td>5</td>
<td>条件、循环与宏</td>
</tr>
<tr>
<td>6</td>
<td>外部项目与 FetchContent</td>
</tr>
<tr>
<td>7</td>
<td>自定义命令与目标</td>
</tr>
<tr>
<td>8</td>
<td>测试与 CTest&#x2F;CDash</td>
</tr>
<tr>
<td>9</td>
<td>安装与导出配置</td>
</tr>
<tr>
<td>10</td>
<td>模块化与大型工程架构</td>
</tr>
</tbody></table>
<p>🎯 现在你能从零设计、构建、测试、安装并复用跨平台 CMake 项目。  </p>
<hr>
<hr>
<h1 id="📘-附录-CMake-常用命令、变量与生成表达式速查表"><a href="#📘-附录-CMake-常用命令、变量与生成表达式速查表" class="headerlink" title="📘 附录 | CMake 常用命令、变量与生成表达式速查表"></a>📘 附录 | CMake 常用命令、变量与生成表达式速查表</h1><hr>
<h2 id="🔧-A-1-核心命令速查"><a href="#🔧-A-1-核心命令速查" class="headerlink" title="🔧 A.1 核心命令速查"></a>🔧 A.1 核心命令速查</h2><table>
<thead>
<tr>
<th>类别</th>
<th>常用命令</th>
<th>功能概述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>项目初始化</strong></td>
<td><code>cmake_minimum_required()</code></td>
<td>声明所需最低版本</td>
</tr>
<tr>
<td></td>
<td><code>project(&lt;name&gt; VERSION &lt;v&gt; LANGUAGES C CXX)</code></td>
<td>定义项目名称与语言</td>
</tr>
<tr>
<td><strong>构建逻辑</strong></td>
<td><code>add_executable()</code></td>
<td>定义可执行文件</td>
</tr>
<tr>
<td></td>
<td><code>add_library()</code></td>
<td>定义静态或动态库</td>
</tr>
<tr>
<td></td>
<td><code>target_link_libraries()</code></td>
<td>绑定依赖目标</td>
</tr>
<tr>
<td></td>
<td><code>target_include_directories()</code></td>
<td>设置头文件路径</td>
</tr>
<tr>
<td></td>
<td><code>target_compile_definitions()</code></td>
<td>指定宏定义</td>
</tr>
<tr>
<td><strong>变量与选项</strong></td>
<td><code>set()</code></td>
<td>定义变量</td>
</tr>
<tr>
<td></td>
<td><code>option()</code></td>
<td>定义开关</td>
</tr>
<tr>
<td></td>
<td><code>message()</code></td>
<td>输出信息</td>
</tr>
<tr>
<td><strong>目录层级</strong></td>
<td><code>add_subdirectory()</code></td>
<td>包含子目录</td>
</tr>
<tr>
<td></td>
<td><code>include()</code></td>
<td>引入脚本文件</td>
</tr>
<tr>
<td><strong>条件与循环</strong></td>
<td><code>if()/elseif()/else()/endif()</code></td>
<td>条件判断</td>
</tr>
<tr>
<td></td>
<td><code>foreach()/endforeach()</code></td>
<td>循环迭代</td>
</tr>
<tr>
<td></td>
<td><code>while()/endwhile()</code></td>
<td>条件循环</td>
</tr>
<tr>
<td><strong>安装与打包</strong></td>
<td><code>install()</code></td>
<td>安装文件&#x2F;目标</td>
</tr>
<tr>
<td></td>
<td><code>include(CPack)</code></td>
<td>启动打包系统</td>
</tr>
<tr>
<td><strong>测试</strong></td>
<td><code>enable_testing()</code></td>
<td>开启测试功能</td>
</tr>
<tr>
<td></td>
<td><code>add_test()</code></td>
<td>注册测试</td>
</tr>
<tr>
<td></td>
<td><code>ctest</code></td>
<td>命令行执行测试</td>
</tr>
<tr>
<td><strong>自定义行为</strong></td>
<td><code>add_custom_command()</code></td>
<td>自定义命令</td>
</tr>
<tr>
<td></td>
<td><code>add_custom_target()</code></td>
<td>自定义目标</td>
</tr>
<tr>
<td><strong>导入与依赖</strong></td>
<td><code>find_package()</code></td>
<td>查找外部库</td>
</tr>
<tr>
<td></td>
<td><code>find_library()</code> &#x2F; <code>find_path()</code></td>
<td>查找文件或库路径</td>
</tr>
<tr>
<td><strong>脚本与函数</strong></td>
<td><code>function()</code></td>
<td>定义局部函数</td>
</tr>
<tr>
<td></td>
<td><code>macro()</code></td>
<td>定义宏</td>
</tr>
<tr>
<td><strong>导出复用</strong></td>
<td><code>install(EXPORT …)</code></td>
<td>安装导出目标</td>
</tr>
<tr>
<td></td>
<td><code>export(EXPORT …)</code></td>
<td>导出构建内目标</td>
</tr>
</tbody></table>
<hr>
<h2 id="🧩-A-2-重要变量速查"><a href="#🧩-A-2-重要变量速查" class="headerlink" title="🧩 A.2 重要变量速查"></a>🧩 A.2 重要变量速查</h2><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_SOURCE_DIR</code></td>
<td>顶层源目录</td>
</tr>
<tr>
<td><code>CMAKE_BINARY_DIR</code></td>
<td>顶层构建目录</td>
</tr>
<tr>
<td><code>CMAKE_CURRENT_SOURCE_DIR</code></td>
<td>当前脚本源目录</td>
</tr>
<tr>
<td><code>CMAKE_CURRENT_BINARY_DIR</code></td>
<td>当前脚本构建目录</td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_PREFIX</code></td>
<td>安装路径</td>
</tr>
<tr>
<td><code>CMAKE_BUILD_TYPE</code></td>
<td>构建类型（Debug&#x2F;Release）</td>
</tr>
<tr>
<td><code>PROJECT_SOURCE_DIR</code> &#x2F; <code>PROJECT_BINARY_DIR</code></td>
<td>当前项目路径</td>
</tr>
<tr>
<td><code>CMAKE_CXX_STANDARD</code></td>
<td>设置 C++ 标准版本</td>
</tr>
<tr>
<td><code>CMAKE_MODULE_PATH</code></td>
<td>查找自定义模块路径</td>
</tr>
<tr>
<td><code>CMAKE_PREFIX_PATH</code></td>
<td>提示 find_package() 查找前缀</td>
</tr>
<tr>
<td><code>CMAKE_TOOLCHAIN_FILE</code></td>
<td>指定交叉编译工具链文件</td>
</tr>
<tr>
<td><code>CMAKE_GENERATOR</code></td>
<td>当前生成器类型</td>
</tr>
<tr>
<td><code>CMAKE_EXPORT_COMPILE_COMMANDS</code></td>
<td>输出 compile_commands.json</td>
</tr>
</tbody></table>
<hr>
<h2 id="⚙️-A-3-常用生成表达式（Generator-Expressions）"><a href="#⚙️-A-3-常用生成表达式（Generator-Expressions）" class="headerlink" title="⚙️ A.3 常用生成表达式（Generator Expressions）"></a>⚙️ A.3 常用生成表达式（Generator Expressions）</h2><table>
<thead>
<tr>
<th>表达式</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>$&lt;CONFIG:Debug&gt;</code></td>
<td>在 Debug 配置时为真</td>
</tr>
<tr>
<td><code>$&lt;STREQUAL:a,b&gt;</code></td>
<td>判断字符串相等</td>
</tr>
<tr>
<td><code>$&lt;PLATFORM_ID:Windows&gt;</code></td>
<td>匹配特定平台</td>
</tr>
<tr>
<td><code>$&lt;COMPILE_LANG_AND_ID:CXX,Clang&gt;</code></td>
<td>检测编译器</td>
</tr>
<tr>
<td><code>$&lt;TARGET_EXISTS:foo&gt;</code></td>
<td>判断目标是否存在</td>
</tr>
<tr>
<td><code>$&lt;BUILD_INTERFACE:…&gt;</code></td>
<td>构建阶段有效内容</td>
</tr>
<tr>
<td><code>$&lt;INSTALL_INTERFACE:…&gt;</code></td>
<td>安装阶段有效内容</td>
</tr>
<tr>
<td><code>$&lt;BOOL:var&gt;</code></td>
<td>布尔取值</td>
</tr>
<tr>
<td><code>$&lt;IF:cond,then,else&gt;</code></td>
<td>条件表达式</td>
</tr>
<tr>
<td><code>$&lt;AND:cond1,cond2&gt;</code></td>
<td>与逻辑</td>
</tr>
<tr>
<td><code>$&lt;OR:cond1,cond2&gt;</code></td>
<td>或逻辑</td>
</tr>
</tbody></table>
<p>常见用法：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(mylib PUBLIC</span><br><span class="line">  $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">  $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧰-A-4-CTest-命令速查"><a href="#🧰-A-4-CTest-命令速查" class="headerlink" title="🧰 A.4 CTest 命令速查"></a>🧰 A.4 CTest 命令速查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>ctest -N</code></td>
<td>仅列出测试</td>
</tr>
<tr>
<td><code>ctest -V</code></td>
<td>详细模式</td>
</tr>
<tr>
<td><code>ctest -R &lt;regex&gt;</code></td>
<td>按名称筛选</td>
</tr>
<tr>
<td><code>ctest --output-on-failure</code></td>
<td>仅输出失败测试信息</td>
</tr>
<tr>
<td><code>ctest -L &lt;label&gt;</code></td>
<td>按标签执行</td>
</tr>
<tr>
<td><code>ctest -T memcheck</code></td>
<td>运行内存检查</td>
</tr>
<tr>
<td><code>ctest -T coverage</code></td>
<td>运行覆盖率测试</td>
</tr>
<tr>
<td><code>ctest -S &lt;script&gt;</code></td>
<td>运行脚本模式</td>
</tr>
</tbody></table>
<hr>
<h2 id="🪣-A-5-目录组织风格与命名建议"><a href="#🪣-A-5-目录组织风格与命名建议" class="headerlink" title="🪣 A.5 目录组织风格与命名建议"></a>🪣 A.5 目录组织风格与命名建议</h2><table>
<thead>
<tr>
<th>项目部分</th>
<th>示例</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>主代码</td>
<td><code>src/</code></td>
<td>按模块细分：core、ui、net</td>
</tr>
<tr>
<td>头文件</td>
<td><code>include/&lt;project&gt;/</code></td>
<td>对外接口</td>
</tr>
<tr>
<td>单元测试</td>
<td><code>tests/</code></td>
<td>一致的命名：<code>test_*.cpp</code></td>
</tr>
<tr>
<td>示例</td>
<td><code>examples/</code></td>
<td>教学或验证代码</td>
</tr>
<tr>
<td>CMake 脚本</td>
<td><code>cmake/</code></td>
<td>存放 Find 模块 &#x2F; 工具函数</td>
</tr>
<tr>
<td>输出目录</td>
<td><code>build/</code></td>
<td>源码外构建</td>
</tr>
<tr>
<td>安装产物</td>
<td><code>dist/</code> 或 <code>install/</code></td>
<td>发布包</td>
</tr>
</tbody></table>
<hr>
<h2 id="📜-A-6-实用技巧汇总"><a href="#📜-A-6-实用技巧汇总" class="headerlink" title="📜 A.6 实用技巧汇总"></a>📜 A.6 实用技巧汇总</h2><ul>
<li>使用 <code>target_*</code> 系列代替全局命令；</li>
<li>自动检测编译器支持：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(CheckCXXCompilerFlag)</span><br><span class="line">check_cxx_compiler_flag(<span class="string">&quot;-std=c++20&quot;</span> HAS_CXX20)</span><br></pre></td></tr></table></figure></li>
<li>通过 <code>FetchContent</code> 管理轻量依赖；</li>
<li>使用 <code>find_package(... CONFIG REQUIRED)</code> 优先导入现代 CMake 包；</li>
<li>在多平台脚本中利用生成表达式控制差异；</li>
<li>构建型导出与安装型导出结合，提高复用性；</li>
<li>确保项目最顶层 <code>CMakeLists.txt</code> 干净简明，可作为示例教学；</li>
<li>采用 <code>ctest</code> 持续测试和 CDash 可视化结果。</li>
</ul>
<hr>
<h2 id="🧭-A-7-参考与后续学习路线"><a href="#🧭-A-7-参考与后续学习路线" class="headerlink" title="🧭 A.7 参考与后续学习路线"></a>🧭 A.7 参考与后续学习路线</h2><table>
<thead>
<tr>
<th>主题</th>
<th>推荐资源</th>
</tr>
</thead>
<tbody><tr>
<td>官方文档</td>
<td><a href="https://cmake.org/cmake/help/latest">https://cmake.org/cmake/help/latest</a></td>
</tr>
<tr>
<td>Kitware Blog</td>
<td>深入讲解现代 CMake 特性与实践</td>
</tr>
<tr>
<td>“Effective Modern CMake”（开源电子书）</td>
<td>系统整理现代用法</td>
</tr>
<tr>
<td>GoogleTest &#x2F; Catch2 集成</td>
<td>官方示例仓库</td>
</tr>
<tr>
<td>Conan &#x2F; vcpkg</td>
<td>构建与打包生态工具</td>
</tr>
</tbody></table>
<hr>
<h2 id="🎓-结语"><a href="#🎓-结语" class="headerlink" title="🎓 结语"></a>🎓 结语</h2><p>你已经完整掌握从基础到进阶的 CMake 工程技巧：<br>从 <strong>构建系统生成 → 模块化依赖管理 → 测试 → 安装打包 → 复用与发布</strong>。  </p>
<p>无论是小型开源库还是企业级跨平台项目，<br>这套体系都能直接应用。  </p>
<hr>
<p>✅ <strong>学习完结</strong></p>
<blockquote>
<p>恭喜完成《现代 CMake 开发与工程实践指南》🎉<br>可以自行创建项目、维护模块库和集成 CI&#x2F;CD 测试！</p>
</blockquote>
<hr>
<hr>
<h1 id="🏗️-CMake-项目脚手架模板"><a href="#🏗️-CMake-项目脚手架模板" class="headerlink" title="🏗️ CMake 项目脚手架模板"></a>🏗️ CMake 项目脚手架模板</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProject/                # 项目根目录</span><br><span class="line">├─ CMakeLists.txt         # 顶层配置</span><br><span class="line">├─ include/</span><br><span class="line">│   └─ myproject/</span><br><span class="line">│       └─ myproject.h</span><br><span class="line">├─ src/</span><br><span class="line">│   ├─ CMakeLists.txt</span><br><span class="line">│   └─ myproject.cpp</span><br><span class="line">├─ tests/</span><br><span class="line">│   ├─ CMakeLists.txt</span><br><span class="line">│   └─ test_main.cpp</span><br><span class="line">├─ cmake/</span><br><span class="line">│   └─ Utils.cmake        # 工具模块示例</span><br><span class="line">└─ README.md</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-顶层-CMakeLists-txt"><a href="#🧩-顶层-CMakeLists-txt" class="headerlink" title="🧩 顶层 CMakeLists.txt"></a>🧩 顶层 CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span>.<span class="number">0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1️⃣ 全局设置</span></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_EXTENSIONS <span class="keyword">OFF</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_EXPORT_COMPILE_COMMANDS <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(ENABLE_TESTS <span class="string">&quot;Build and run unit tests&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"><span class="keyword">list</span>(APPEND CMAKE_MODULE_PATH <span class="string">&quot;$&#123;CMAKE_SOURCE_DIR&#125;/cmake&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2️⃣ 子目录</span></span><br><span class="line"><span class="keyword">add_subdirectory</span>(src)</span><br><span class="line"><span class="keyword">if</span>(ENABLE_TESTS)</span><br><span class="line">  <span class="keyword">enable_testing</span>()</span><br><span class="line">  <span class="keyword">add_subdirectory</span>(tests)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3️⃣ 安装导出配置（可选）</span></span><br><span class="line"><span class="keyword">include</span>(CMakePackageConfigHelpers)</span><br><span class="line"><span class="keyword">install</span>(TARGETS myproject</span><br><span class="line">  <span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin)</span><br><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="keyword">include</span>/ DESTINATION <span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  <span class="keyword">FILE</span> MyProjectTargets.cmake</span><br><span class="line">  NAMESPACE MyProject::</span><br><span class="line">  DESTINATION lib/cmake/MyProject)</span><br><span class="line"></span><br><span class="line">configure_package_config_file(</span><br><span class="line">  cmake/MyProjectConfig.cmake.in</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjectConfig.cmake&quot;</span></span><br><span class="line">  INSTALL_DESTINATION lib/cmake/MyProject)</span><br><span class="line"></span><br><span class="line">write_basic_package_version_file(</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjectConfigVersion.cmake&quot;</span></span><br><span class="line">  VERSION <span class="variable">$&#123;PROJECT_VERSION&#125;</span></span><br><span class="line">  COMPATIBILITY SameMajorVersion)</span><br><span class="line"></span><br><span class="line"><span class="keyword">install</span>(FILES</span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjectConfig.cmake&quot;</span></span><br><span class="line">  <span class="string">&quot;$&#123;CMAKE_CURRENT_BINARY_DIR&#125;/MyProjectConfigVersion.cmake&quot;</span></span><br><span class="line">  DESTINATION lib/cmake/MyProject)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4️⃣ CPack 打包</span></span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_VENDOR <span class="string">&quot;YourName&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_CONTACT <span class="string">&quot;you@example.com&quot;</span>)</span><br><span class="line"><span class="keyword">set</span>(CPACK_PACKAGE_FILE_NAME <span class="string">&quot;$&#123;PROJECT_NAME&#125;-$&#123;PROJECT_VERSION&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">include</span>(CPack)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚙️-src-CMakeLists-txt"><a href="#⚙️-src-CMakeLists-txt" class="headerlink" title="⚙️ src&#x2F;CMakeLists.txt"></a>⚙️ src&#x2F;CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(myproject myproject.cpp)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_include_directories</span>(myproject</span><br><span class="line">  PUBLIC</span><br><span class="line">    $&lt;BUILD_INTERFACE:<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/<span class="keyword">include</span>&gt;</span><br><span class="line">    $&lt;INSTALL_INTERFACE:<span class="keyword">include</span>&gt;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_compile_features</span>(myproject PUBLIC cxx_std_17)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义函数（演示）：</span></span><br><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cmake/Utils.cmake)</span><br><span class="line">add_my_compile_options(myproject)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="✨-cmake-Utils-cmake"><a href="#✨-cmake-Utils-cmake" class="headerlink" title="✨ cmake&#x2F;Utils.cmake"></a>✨ cmake&#x2F;Utils.cmake</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(add_my_compile_options <span class="keyword">target</span>)</span><br><span class="line">  <span class="keyword">message</span>(STATUS <span class="string">&quot;Applying default warnings to target $&#123;target&#125;&quot;</span>)</span><br><span class="line">  <span class="keyword">target_compile_options</span>(<span class="variable">$&#123;target&#125;</span></span><br><span class="line">    PRIVATE</span><br><span class="line">      $&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/W4 /permissive-&gt;</span><br><span class="line">      $&lt;$&lt;<span class="keyword">NOT</span>:$CXX_COMPILER_ID:MSVC&gt;&gt;:-Wall -Wextra -Wpedantic&gt;)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧱-src-myproject-cpp"><a href="#🧱-src-myproject-cpp" class="headerlink" title="🧱 src&#x2F;myproject.cpp"></a>🧱 src&#x2F;myproject.cpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myproject/myproject.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myproject::say_hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, CMake world!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📘-include-myproject-myproject-h"><a href="#📘-include-myproject-myproject-h" class="headerlink" title="📘 include&#x2F;myproject&#x2F;myproject.h"></a>📘 include&#x2F;myproject&#x2F;myproject.h</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="keyword">namespace</span> myproject &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">say_hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧪-tests-CMakeLists-txt"><a href="#🧪-tests-CMakeLists-txt" class="headerlink" title="🧪 tests&#x2F;CMakeLists.txt"></a>🧪 tests&#x2F;CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(test_main test_main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(test_main PRIVATE myproject)</span><br><span class="line"><span class="keyword">add_test</span>(NAME test_main <span class="keyword">COMMAND</span> test_main)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧪-tests-test-main-cpp"><a href="#🧪-tests-test-main-cpp" class="headerlink" title="🧪 tests&#x2F;test_main.cpp"></a>🧪 tests&#x2F;test_main.cpp</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;myproject/myproject.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    myproject::<span class="built_in">say_hello</span>();</span><br><span class="line">    <span class="comment">// 简单验证输出，可扩展为单元测试框架（如 Catch2 或 GoogleTest）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📥-构建与测试指令"><a href="#📥-构建与测试指令" class="headerlink" title="📥 构建与测试指令"></a>📥 构建与测试指令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1️⃣ 配置构建</span></span><br><span class="line">cmake -S . -B build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2️⃣ 编译</span></span><br><span class="line">cmake --build build -j</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3️⃣ 运行测试</span></span><br><span class="line">ctest --test-dir build --output-on-failure</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4️⃣ 安装到本地（默认 /usr/local）</span></span><br><span class="line">cmake --install build</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5️⃣ 打包</span></span><br><span class="line">cpack --config build/CPackConfig.cmake</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<p>✅ 这一套模板能立即运行：<br>在一个空目录中复制这些文件 → 构建 → 运行 → 看到<br><code>Hello, CMake world!</code> 输出，即成功！</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>你好并发世界文摘</title>
    <url>/%E4%BD%A0%E5%A5%BD%E5%B9%B6%E5%8F%91%E4%B8%96%E7%95%8C%E6%96%87%E6%91%98/</url>
    <content><![CDATA[<span id="more"></span>

<p><a href="https://nj.gitbooks.io/c/content/"></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.2 为什么使用并发？</span><br><span class="line">主要原因有两个：关注点分离(SOC)和性能。</span><br></pre></td></tr></table></figure>
<p>2种并发方式，多进程 和 多线程<br>多进程： 开销更大，进程间通信更麻烦(IPC)</p>
<p>进程内存布局(may 1Mb)<br>0x100000    high address<br>0x …         command-line arguments and variables<br>0x …         stack<br>0x …         heap<br>0x …         uninitialized data(bss), initialized to zero by exec<br>0x …         initialized data       , read from program file by exec<br>0x …         text                   , read from program file by exec<br>0x000000    low address                                         </p>
<p>线程之间共享<br> uninitialized data(bss)<br> initialized data<br> text</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两种方式利用并发提高性能：</span><br><span class="line">第一，将一个单个任务分成几部分，且各自并行运行，从而降低总运行时间。这就是任务并行（task parallelism）</span><br><span class="line">第二，一个线程执行算法的一部分, 另一个线程执行算法的另一个部分——或是在数据方面——每个线程在不同的数据部分上执行相同的操作, 数据并行（data parallelism）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.2.3 什么时候不使用并发</span><br><span class="line">操作系统需要分配内核相关资源和堆栈空间，所以在启动线程时存在固有的开销，然后才能把新线程加入调度器中，所有这一切都需要时间。如果在线程上的任务完成得很快，那么任务实际执行的时间要比启动线程的时间小很多，这就会导致应用程序的整体性能还不如直接使用“产生线程”的方式。</span><br><span class="line"></span><br><span class="line">运行越多的线程，操作系统就需要做越多的上下文切换，每个上下文切换都需要耗费本可以花在有价值工作上的时间。所以在某些时候，增加一个额外的线程实际上会降低，而非提高应用程序的整体性能。为此，如果你试图得到系统的最佳性能，可以考虑使用硬件并发(或不用)，并调整运行线程的数量。</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>成员函数的隐藏参数this, 在C语言中的样子</title>
    <url>/%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%9A%90%E8%97%8F%E5%8F%82%E6%95%B0this-%E5%9C%A8C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%A0%B7%E5%AD%90/</url>
    <content><![CDATA[<p>在C++中，成员函数有一个隐藏参数 this，它是指向调用该函数的对象实例的指针。这个特性是C++面向对象编程的核心之一，但在C语言层面，C++的这种机制会被编译器“翻译”成更底层的实现方式。</p>
<span id="more"></span>
<h2 id="在C语言层面的表现"><a href="#在C语言层面的表现" class="headerlink" title="在C语言层面的表现"></a>在C语言层面的表现</h2><p>在C语言中, 没有类的概念, 因此C++的成员函数会被编译器转换为普通的全局函数, 而 this 指针会作为显式的参数传递给这个函数. 具体来说:<br>成员函数被转换为普通函数: 编译器会将类中的成员函数变成一个普通的C风格函数, 函数名通常会经过”名称修饰”(name mangling), 以避免命名冲突并保留类的信息(函数的唯一签名)<br>this 指针作为显式参数: this这个参数 会被替换成指向对象的结构体指针传入函数</p>
<p>例如, 如下C++代码:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        value = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">MyClass obj;</span><br><span class="line">obj.<span class="built_in">setValue</span>(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>在C语言层面, 编译器可能会将其转换为类似如下的形式:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">MyClass_setValue</span><span class="params">(<span class="keyword">struct</span> MyClass* this, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    this-&gt;value = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyClass</span> <span class="title">obj</span>;</span></span><br><span class="line">MyClass_setValue(&amp;obj, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>

<p>MyClass 被转换为了一个 struct<br>setValue 成员函数被转换为一个签名唯一的全局函数 MyClass_setValue<br>this 指针被显式地作为第一个参数传递, 指向调用该函数的对象实例(&amp;obj)</p>
<h2 id="this-参数在第几个位置"><a href="#this-参数在第几个位置" class="headerlink" title="this 参数在第几个位置"></a>this 参数在第几个位置</h2><p>在C语言层面，this 参数通常是函数的第一个参数. 这是C++编译器的惯例, 因为 this 必须在函数调用时明确知道它操作的是哪个对象实例. 其他显式参数(如 x)则依次排在后面<br>例如，对于一个带有多个参数的成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> a, <span class="type">double</span> b)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在C语言层面可能是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MyClass_func</span><span class="params">(<span class="keyword">struct</span> MyClass* this, <span class="type">int</span> a, <span class="type">double</span> b)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>this 是第 1 个参数<br>a 是第 2 个参数<br>b 是第 3 个参数</p>
<p>所以在C语言层面，this 被显式地作为指向对象实例的指针参数传递<br>它通常是函数的第一个参数, 因为这是C++编译器实现调用约定时的标准做法<br>这种转换由编译器自动完成, 程序员在C++层面无需手动处理 this</p>
]]></content>
  </entry>
  <entry>
    <title>简明CMAKE语法与工程管理指南</title>
    <url>/%E7%AE%80%E6%98%8ECMAKE%E8%AF%AD%E6%B3%95%E4%B8%8E%E5%B7%A5%E7%A8%8B%E7%AE%A1%E7%90%86%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h2 id="快速认识CMake，并掌握简单的工程化的能力-补充内容，如果还有遗漏可以到完全手册中查询相关说明"><a href="#快速认识CMake，并掌握简单的工程化的能力-补充内容，如果还有遗漏可以到完全手册中查询相关说明" class="headerlink" title="快速认识CMake，并掌握简单的工程化的能力, 补充内容，如果还有遗漏可以到完全手册中查询相关说明"></a>快速认识CMake，并掌握简单的工程化的能力, 补充内容，如果还有遗漏可以到完全手册中查询相关说明<br><span id="more"></span></h2><h1 id="第一部分：原文稿"><a href="#第一部分：原文稿" class="headerlink" title="第一部分：原文稿"></a>第一部分：原文稿</h1><hr>
<hr>
<h1 id="🧭-总览结构"><a href="#🧭-总览结构" class="headerlink" title="🧭 总览结构"></a>🧭 总览结构</h1><ol>
<li><strong>CMake 概念速览与层次关系</strong>  <ul>
<li>命令行语法 vs. 脚本语法</li>
<li>工程组织思想</li>
</ul>
</li>
<li><strong>CMake 语法大全（脚本语法 + 命令行语法）</strong><ul>
<li>语言结构、控制流、变量、函数、宏</li>
<li>常用命令（add、target、link、install、export等）</li>
<li>命令行工具（<code>cmake</code>、<code>ctest</code>、<code>cpack</code>）</li>
</ul>
</li>
<li><strong>工程实战模板与范例</strong><ul>
<li>标准项目结构 + 含多子库&#x2F;动态&#x2F;静态 + 外部库 + 头文件引用 + install&#x2F;export</li>
<li>附带易理解的 C++ 示例代码</li>
<li>分级解释作用、可直接编译运行</li>
</ul>
</li>
</ol>
<hr>
<h1 id="🧩-PART-I：CMake-概念与结构"><a href="#🧩-PART-I：CMake-概念与结构" class="headerlink" title="🧩 PART I：CMake 概念与结构"></a>🧩 PART I：CMake 概念与结构</h1><h2 id="🍀-CMake-是“两层语言”"><a href="#🍀-CMake-是“两层语言”" class="headerlink" title="🍀 CMake 是“两层语言”"></a>🍀 CMake 是“两层语言”</h2><table>
<thead>
<tr>
<th>层</th>
<th>描述</th>
<th>类比</th>
</tr>
</thead>
<tbody><tr>
<td><strong>脚本语法</strong></td>
<td>CMakeLists.txt 文件，由 CMake 语法组成，用来描述工程规则</td>
<td>Shell 脚本</td>
</tr>
<tr>
<td><strong>命令行接口</strong></td>
<td>cmake CLI 命令，用于配置、构建、安装、测试、打包</td>
<td>控制面板</td>
</tr>
</tbody></table>
<p>!&gt; <strong>CMake 不是编译器，也不执行 make，它生成编译系统（Makefile&#x2F;Ninja&#x2F;VS）后再委托编译。</strong></p>
<hr>
<h1 id="🧱-PART-II：CMake-语法大全"><a href="#🧱-PART-II：CMake-语法大全" class="headerlink" title="🧱 PART II：CMake 语法大全"></a>🧱 PART II：CMake 语法大全</h1><hr>
<h2 id="📘-1-基本脚本语法结构"><a href="#📘-1-基本脚本语法结构" class="headerlink" title="📘 1. 基本脚本语法结构"></a>📘 1. 基本脚本语法结构</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注释</span></span><br><span class="line"><span class="comment"># 单行注以 # 开头</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 语句格式：命令(参数1 参数2 ...)</span></span><br><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定最小版本</span></span><br><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔤-2-变量与作用域"><a href="#🔤-2-变量与作用域" class="headerlink" title="🔤 2. 变量与作用域"></a>🔤 2. 变量与作用域</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下方有补充解释</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>普通变量</td>
<td><code>set(VAR value)</code></td>
<td>定义变量</td>
</tr>
<tr>
<td>访问变量</td>
<td><code>$&#123;VAR&#125;</code></td>
<td>取值</td>
</tr>
<tr>
<td>环境变量</td>
<td><code>$ENV&#123;PATH&#125;</code></td>
<td>环境访问</td>
</tr>
<tr>
<td>缓存变量</td>
<td><code>set(VAR value CACHE STRING &quot;desc&quot;)</code></td>
<td>跨运行</td>
</tr>
<tr>
<td>条件判断</td>
<td><code>if(VAR)</code> … <code>elseif(...)</code> … <code>endif()</code></td>
<td>控制流</td>
</tr>
<tr>
<td>比较</td>
<td><code>if(VALUE STREQUAL &quot;abc&quot;)</code></td>
<td>字符串比较</td>
</tr>
<tr>
<td>列表</td>
<td><code>set(LIST a b c)</code></td>
<td>定义列表</td>
</tr>
<tr>
<td>操作</td>
<td><code>list(APPEND LST val)</code></td>
<td>列表操作</td>
</tr>
</tbody></table>
<p>❗常用变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMAKE_SOURCE_DIR            # 顶层源码目录</span><br><span class="line">CMAKE_BINARY_DIR            # 构建输出目录</span><br><span class="line">PROJECT_NAME                # 当前project()</span><br><span class="line">CMAKE_BUILD_TYPE            # Debug/Release</span><br><span class="line">CMAKE_INSTALL_PREFIX         # 安装路径</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="⚙️-3-函数与宏"><a href="#⚙️-3-函数与宏" class="headerlink" title="⚙️ 3. 函数与宏"></a>⚙️ 3. 函数与宏</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span>(print_status msg)</span><br><span class="line">    <span class="keyword">message</span>(STATUS <span class="string">&quot;&gt;&gt;&gt; $&#123;msg&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endfunction</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">macro</span>(print_debug VAR)</span><br><span class="line">    <span class="keyword">message</span>(<span class="string">&quot;DBG: $&#123;VAR&#125;=$&#123;$&#123;VAR&#125;&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">endmacro</span>()</span><br></pre></td></tr></table></figure>

<p>区别：</p>
<ul>
<li><code>function()</code> 创建独立作用域；</li>
<li><code>macro()</code> 没有作用域（变量变化会传出）。</li>
</ul>
<hr>
<h2 id="🧭-4-流程控制与逻辑表达式"><a href="#🧭-4-流程控制与逻辑表达式" class="headerlink" title="🧭 4. 流程控制与逻辑表达式"></a>🧭 4. 流程控制与逻辑表达式</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(WIN32)</span><br><span class="line"> <span class="keyword">message</span>(<span class="string">&quot;Windows build&quot;</span>)</span><br><span class="line"><span class="keyword">elseif</span>(UNIX)</span><br><span class="line"> <span class="keyword">message</span>(<span class="string">&quot;Linux build&quot;</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="keyword">file</span> IN LISTS myfiles)</span><br><span class="line"> <span class="keyword">message</span>(<span class="variable">$&#123;file&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(cond)</span><br><span class="line"> ...</span><br><span class="line"><span class="keyword">endwhile</span>()</span><br></pre></td></tr></table></figure>

<p>运算符：</p>
<ul>
<li><code>STREQUAL</code>, <code>EQUAL</code>, <code>LESS</code>, <code>GREATER</code></li>
<li><code>AND</code>, <code>OR</code>, <code>NOT</code></li>
<li>文件判断：<code>if(EXISTS path)</code>, <code>if(IS_DIRECTORY dir)</code></li>
</ul>
<hr>
<h2 id="🪶-5-输入输出与消息"><a href="#🪶-5-输入输出与消息" class="headerlink" title="🪶 5. 输入输出与消息"></a>🪶 5. 输入输出与消息</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Compiling...&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(WARNING <span class="string">&quot;dangerous&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(FATAL_ERROR <span class="string">&quot;stop!&quot;</span>)</span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> path)</span><br><span class="line"><span class="keyword">file</span>(GLOB SRCS <span class="string">&quot;*.cpp&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-6-核心构建指令"><a href="#🧩-6-核心构建指令" class="headerlink" title="🧩 6. 核心构建指令"></a>🧩 6. 核心构建指令</h2><table>
<thead>
<tr>
<th>功能</th>
<th>使用语法</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>可执行程序</td>
<td><code>add_executable(target src...)</code></td>
<td><code>add_executable(App main.cpp)</code></td>
</tr>
<tr>
<td>静态&#x2F;动态库</td>
<td><code>add_library(name STATIC/SHARED src...)</code></td>
<td></td>
</tr>
<tr>
<td>目标属性</td>
<td><code>set_target_properties(tgt PROPERTIES OUTPUT_NAME &quot;libcore&quot;)</code></td>
<td></td>
</tr>
<tr>
<td>链接依赖</td>
<td><code>target_link_libraries(A B PRIVATE C)</code></td>
<td></td>
</tr>
<tr>
<td>包含目录</td>
<td><code>target_include_directories(A PUBLIC include/)</code></td>
<td></td>
</tr>
<tr>
<td>定义宏</td>
<td><code>target_compile_definitions(A PRIVATE BUILD_DLL)</code></td>
<td></td>
</tr>
<tr>
<td>选项</td>
<td><code>option(ENABLE_LOG &quot;enable log&quot; ON)</code></td>
<td></td>
</tr>
<tr>
<td>条件编译</td>
<td><code>if(ENABLE_LOG)</code>…<code>endif()</code></td>
<td></td>
</tr>
</tbody></table>
<p><strong>三种可见性关键字：</strong></p>
<ul>
<li><strong>PRIVATE</strong>：仅当前 target；</li>
<li><strong>PUBLIC</strong>：当前和依赖当前的 target；</li>
<li><strong>INTERFACE</strong>：只有调用者可见。</li>
</ul>
<hr>
<h2 id="🏗️-7-全局与子目录构建"><a href="#🏗️-7-全局与子目录构建" class="headerlink" title="🏗️ 7. 全局与子目录构建"></a>🏗️ 7. 全局与子目录构建</h2><h3 id="主次结构"><a href="#主次结构" class="headerlink" title="主次结构"></a>主次结构</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_subdirectory</span>(Core)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(Modules)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(App)</span><br></pre></td></tr></table></figure>

<h3 id="include-引用模块"><a href="#include-引用模块" class="headerlink" title="include 引用模块"></a>include 引用模块</h3><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(<span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/cmake/MyUtil.cmake)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🗂️-8-安装与导出（Install-Export）"><a href="#🗂️-8-安装与导出（Install-Export）" class="headerlink" title="🗂️ 8. 安装与导出（Install &#x2F; Export）"></a>🗂️ 8. 安装与导出（Install &#x2F; Export）</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS Core Model</span><br><span class="line">  <span class="keyword">EXPORT</span> MyProjTargets</span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjTargets</span><br><span class="line">  <span class="keyword">FILE</span> MyProjConfig.cmake</span><br><span class="line">  NAMESPACE MyProj::</span><br><span class="line">  DESTINATION lib/cmake/MyProj</span><br><span class="line">)</span><br><span class="line"><span class="keyword">install</span>(DIRECTORY <span class="keyword">include</span>/ DESTINATION <span class="keyword">include</span>/MyProj)</span><br></pre></td></tr></table></figure>

<p>这样 <code>find_package(MyProj REQUIRED)</code> 即可导入。</p>
<hr>
<h2 id="💼-9-导入外部库与-find-package"><a href="#💼-9-导入外部库与-find-package" class="headerlink" title="💼 9. 导入外部库与 find_package"></a>💼 9. 导入外部库与 find_package</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(App PRIVATE <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>自定义 <code>FindXXX.cmake</code>：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cmake/FindMylib.cmake</span></span><br><span class="line"><span class="keyword">find_path</span>(MYLIB_INCLUDE_DIR mylib.h PATHS /opt/mylib/<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">find_library</span>(MYLIB_LIB NAMES mylib PATHS /opt/mylib/lib)</span><br><span class="line"><span class="keyword">mark_as_advanced</span>(MYLIB_INCLUDE_DIR MYLIB_LIB)</span><br><span class="line"><span class="keyword">if</span>(MYLIB_INCLUDE_DIR <span class="keyword">AND</span> MYLIB_LIB)</span><br><span class="line">  <span class="keyword">set</span>(MYLIB_FOUND <span class="keyword">TRUE</span>)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔗-10-工程属性与配置"><a href="#🔗-10-工程属性与配置" class="headerlink" title="🔗 10. 工程属性与配置"></a>🔗 10. 工程属性与配置</h2><table>
<thead>
<tr>
<th>命令</th>
<th>示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>project(NAME VERSION 1.0)</code></td>
<td>—</td>
<td>工程名和版本</td>
</tr>
<tr>
<td><code>configure_file(in out @ONLY)</code></td>
<td>模板生成配置头</td>
<td></td>
</tr>
<tr>
<td><code>add_compile_options(-Wall)</code></td>
<td>全局编译选项</td>
<td></td>
</tr>
<tr>
<td><code>set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ...)</code></td>
<td>二进制输出目录</td>
<td></td>
</tr>
<tr>
<td><code>include(GNUInstallDirs)</code></td>
<td>平台标准路径</td>
<td></td>
</tr>
<tr>
<td><code>add_custom_command</code> &#x2F; <code>add_custom_target</code></td>
<td>自定义命令</td>
<td></td>
</tr>
</tbody></table>
<p>自定义命令例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_custom_command</span>(</span><br><span class="line">  <span class="keyword">TARGET</span> App POST_BUILD</span><br><span class="line">  <span class="keyword">COMMAND</span> <span class="variable">$&#123;CMAKE_COMMAND&#125;</span> -E copy $&lt;TARGET_FILE:App&gt; <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🧩-11-测试与打包"><a href="#🧩-11-测试与打包" class="headerlink" title="🧩 11. 测试与打包"></a>🧩 11. 测试与打包</h2><ul>
<li>测试：<code>enable_testing()</code> + <code>add_test(NAME test1 COMMAND App arg)</code></li>
<li>打包：  <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">include</span>(CPack)</span><br><span class="line"><span class="keyword">set</span>(CPACK_GENERATOR <span class="string">&quot;TGZ&quot;</span>)</span><br><span class="line">make package</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="⚙️-12-命令行工具语法速查"><a href="#⚙️-12-命令行工具语法速查" class="headerlink" title="⚙️ 12. 命令行工具语法速查"></a>⚙️ 12. 命令行工具语法速查</h2><table>
<thead>
<tr>
<th>命令</th>
<th>功能&#x2F;示例</th>
</tr>
</thead>
<tbody><tr>
<td>创建构建系统</td>
<td><code>cmake -S . -B build</code></td>
</tr>
<tr>
<td>构建</td>
<td><code>cmake --build build -j</code></td>
</tr>
<tr>
<td>安装</td>
<td><code>cmake --install build --prefix ./install</code></td>
</tr>
<tr>
<td>清理</td>
<td><code>cmake --build build --target clean</code></td>
</tr>
<tr>
<td>列变量</td>
<td><code>cmake -LAH</code></td>
</tr>
<tr>
<td>测试</td>
<td><code>ctest --output-on-failure</code></td>
</tr>
<tr>
<td>打包</td>
<td><code>cpack -G TGZ</code></td>
</tr>
<tr>
<td>缓存修改</td>
<td><code>cmake -DVAR=VALUE</code></td>
</tr>
<tr>
<td>GUI (可选)</td>
<td><code>cmake-gui</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="⚒️-PART-III：实战工程模板"><a href="#⚒️-PART-III：实战工程模板" class="headerlink" title="⚒️ PART III：实战工程模板"></a>⚒️ PART III：实战工程模板</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">工程已作废，下方补充说明部分有更新版本</span><br></pre></td></tr></table></figure>

<h2 id="🎯-工程目标"><a href="#🎯-工程目标" class="headerlink" title="🎯 工程目标"></a>🎯 工程目标</h2><ul>
<li>主项目： <code>MyProject</code></li>
<li>子组件：<ul>
<li><code>Core</code>（静态库）</li>
<li><code>Network</code>（动态库）</li>
<li><code>App</code>（主程序）</li>
</ul>
</li>
<li>额外引入第三方库如 <code>fmt</code>（header-only）</li>
</ul>
<hr>
<h2 id="📁-文件结构"><a href="#📁-文件结构" class="headerlink" title="📁 文件结构"></a>📁 文件结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProject/</span><br><span class="line">│</span><br><span class="line">├─ CMakeLists.txt</span><br><span class="line">├─ Core/</span><br><span class="line">│   ├─ CMakeLists.txt</span><br><span class="line">│   └─ core.cpp / core.h</span><br><span class="line">├─ Network/</span><br><span class="line">│   ├─ CMakeLists.txt</span><br><span class="line">│   └─ network.cpp / network.h</span><br><span class="line">├─ App/</span><br><span class="line">│   ├─ CMakeLists.txt</span><br><span class="line">│   └─ main.cpp</span><br><span class="line">├─ cmake/</span><br><span class="line">│   └─ FindFMT.cmake</span><br><span class="line">└─ bin/</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🏷️-顶层-CMakeLists-txt"><a href="#🏷️-顶层-CMakeLists-txt" class="headerlink" title="🏷️ 顶层 CMakeLists.txt"></a>🏷️ 顶层 CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject LANGUAGES CXX VERSION <span class="number">1.0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_LIBRARY_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin/lib)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_ARCHIVE_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin/lib)</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build shared instead of static&quot;</span> <span class="keyword">ON</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(Core)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(Network)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(App)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装导出</span></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  <span class="keyword">FILE</span> MyProjectConfig.cmake</span><br><span class="line">  NAMESPACE MyProject::</span><br><span class="line">  DESTINATION lib/cmake/MyProject</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-Core-CMakeLists-txt"><a href="#🔹-Core-CMakeLists-txt" class="headerlink" title="🔹 Core&#x2F;CMakeLists.txt"></a>🔹 Core&#x2F;CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Core STATIC core.cpp core.h)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Core PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(Core PRIVATE CORE_INTERNAL)</span><br><span class="line"><span class="keyword">install</span>(TARGETS Core <span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">  PUBLIC_HEADER DESTINATION <span class="keyword">include</span>/Core</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>core.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">core_init</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Core initialized\n&quot;</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>core.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">core_init</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-Network-CMakeLists-txt"><a href="#🔹-Network-CMakeLists-txt" class="headerlink" title="🔹 Network&#x2F;CMakeLists.txt"></a>🔹 Network&#x2F;CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Network SHARED network.cpp network.h)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Network PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Network PRIVATE Core)</span><br><span class="line"><span class="keyword">find_package</span>(FMT REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">target_link_libraries</span>(Network PRIVATE fmt::fmt)</span><br><span class="line"><span class="keyword">install</span>(TARGETS Network <span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  PUBLIC_HEADER DESTINATION <span class="keyword">include</span>/Network</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><strong>network.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">network_run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">core_init</span>();</span><br><span class="line">    fmt::<span class="built_in">print</span>(<span class="string">&quot;Network module online.\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>network.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">network_run</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-App-CMakeLists-txt"><a href="#🔹-App-CMakeLists-txt" class="headerlink" title="🔹 App&#x2F;CMakeLists.txt"></a>🔹 App&#x2F;CMakeLists.txt</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(App main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(App PRIVATE Core Network)</span><br><span class="line"><span class="keyword">install</span>(TARGETS App RUNTIME DESTINATION bin)</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;network.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">network_run</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="📦-构建与安装"><a href="#📦-构建与安装" class="headerlink" title="📦 构建与安装"></a>📦 构建与安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build -DCMAKE_BUILD_TYPE=Release</span><br><span class="line">cmake --build build -j</span><br><span class="line">cmake --install build --prefix ./install</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install/</span><br><span class="line">├─ bin/App</span><br><span class="line">├─ lib/libCore.a</span><br><span class="line">├─ lib/libNetwork.so</span><br><span class="line">└─ include/(Core|Network)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🌍-外部使用（SDK形式）"><a href="#🌍-外部使用（SDK形式）" class="headerlink" title="🌍 外部使用（SDK形式）"></a>🌍 外部使用（SDK形式）</h2><p>在另一个 CMake 项目的 CMakeLists.txt：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyProject REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(UserApp main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(UserApp PRIVATE MyProject::Network)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="💡-附录：学习与心法"><a href="#💡-附录：学习与心法" class="headerlink" title="💡 附录：学习与心法"></a>💡 附录：学习与心法</h1><ol>
<li><strong>CMake 是“描述”，不是“执行”</strong> - 它描述「如何构建」。  </li>
<li><strong>最小暴露原则</strong> - 公共接口只通过 <code>target_include_directories(... PUBLIC)</code>。  </li>
<li><strong>不全局污染</strong> - 避免 <code>include_directories(...)</code> 这种全局指令。  </li>
<li><strong>导出&#x2F;Import 是工程复用根基。</strong>  </li>
<li><strong>区分开发与部署</strong> - 使用 INSTALL 和 EXPORT。  </li>
<li><strong>第三方库优先 find_package</strong> - 兼容 CMake生态。  </li>
<li><strong>Debug&#x2F;Release 各独立构建目录。</strong>  </li>
<li><strong>掌握目标依赖三修饰符：PRIVATE &#x2F; PUBLIC &#x2F; INTERFACE。</strong>  </li>
<li><strong>用 configure_file 自动生成版本号头文件。</strong>  </li>
<li><strong>始终在 CMake GUI &#x2F; Cache 里确认路径解析。</strong></li>
</ol>
<hr>
<p>✅ <strong>结果</strong></p>
<p>这份文档包含：</p>
<ul>
<li>全量脚本语法（变量、函数、逻辑、构建命令、安装导出）；</li>
<li>所有命令行接口；</li>
<li>完整高层模板（含三层子项目 + install&#x2F;export + 第三方依赖）；</li>
<li>真实 C++ 示例可编译运行；</li>
<li>行业通用工程组织理念。</li>
</ul>
<p>拷贝工程结构后执行三步：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line">cmake --build build</span><br><span class="line">cmake --install build --prefix ./install</span><br></pre></td></tr></table></figure>

<p>你就拥有了一个标准、现代、可扩展且可复用的 CMake 工程基础框架。</p>
<hr>
<h1 id="第二部分：补充说明"><a href="#第二部分：补充说明" class="headerlink" title="第二部分：补充说明"></a>第二部分：补充说明</h1><hr>
<h1 id="🧱-第一章：变量系统全解（CMake-脚本语法核心）"><a href="#🧱-第一章：变量系统全解（CMake-脚本语法核心）" class="headerlink" title="🧱 第一章：变量系统全解（CMake 脚本语法核心）"></a>🧱 第一章：变量系统全解（CMake 脚本语法核心）</h1><hr>
<h2 id="🔤-1️⃣-定义变量"><a href="#🔤-1️⃣-定义变量" class="headerlink" title="🔤 1️⃣ 定义变量"></a>🔤 1️⃣ 定义变量</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set(&lt;变量名&gt; &lt;值&gt; [CACHE &lt;类型&gt; &lt;描述&gt; [FORCE]])</span></span><br><span class="line"><span class="keyword">set</span>(MY_NAME <span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="variable">$&#123;MY_NAME&#125;</span>) <span class="comment"># 打印变量值 =&gt; Alice</span></span><br></pre></td></tr></table></figure>

<p>📘 <strong>说明</strong></p>
<ul>
<li>CMake 中变量只是。</li>
<li>默认作用域是当前文件；function 有独立作用域，macro 没有。</li>
<li>可跨文件使用 <code>$&#123;变量名&#125;</code> 取值。</li>
</ul>
<hr>
<h2 id="🌍-2️⃣-预定义路径变量"><a href="#🌍-2️⃣-预定义路径变量" class="headerlink" title="🌍 2️⃣ 预定义路径变量"></a>🌍 2️⃣ 预定义路径变量</h2><table>
<thead>
<tr>
<th>变量</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_SOURCE_DIR</code> 最顶层 <code>CMakeLists.txt</code> 所在目录</td>
<td><code>/home/user/MyProject</code></td>
<td></td>
</tr>
<tr>
<td><code>CMAKE_CURRENT_SOURCE_DIR</code></td>
<td>当前这一层CMakeLists所在目录</td>
<td><code>MyProject/Core</code></td>
</tr>
<tr>
<td><code>CMAKE_BINARY_DIR</code></td>
<td>构建目录根</td>
<td><code>/home/user/MyProject/build</code></td>
</tr>
<tr>
<td><code>CMAKE_CURRENT_BINARY_DIR</code></td>
<td>当前构建子目录</td>
<td><code>/home/user/MyProject/build</code></td>
</tr>
<tr>
<td><code>PROJECT_SOURCE_DIR</code></td>
<td><code>project()</code> 定义的项目源码根</td>
<td>同 <code>CMAKE_SOURCE_DIR</code></td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_PREFIX</code></td>
<td>安装根目录</td>
<td><code>/usr/local</code> 或手动prefix</td>
</tr>
<tr>
<td><code>CMAKE_RUNTIME_OUTPUT_DIRECTORY</code></td>
<td>exe 输出路径</td>
<td><code>MyProject/bin</code></td>
</tr>
<tr>
<td><code>CMAKE_LIBRARY_OUTPUT_DIRECTORY</code></td>
<td>动态库输出路径</td>
<td><code>MyProject/bin/lib</code></td>
</tr>
<tr>
<td><code>CMAKE_ARCHIVE_OUTPUT_DIRECTORY</code></td>
<td>静态库输出路径</td>
<td><code>MyProject/bin/lib</code></td>
</tr>
</tbody></table>
<p>💬 用法示例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"><span class="keyword">add_executable</span>(app main.cpp)</span><br></pre></td></tr></table></figure>
<p>→ 编译后 <code>app</code> 输出到 <code>bin/</code></p>
<hr>
<h2 id="📋-3️⃣-环境与缓存变量"><a href="#📋-3️⃣-环境与缓存变量" class="headerlink" title="📋 3️⃣ 环境与缓存变量"></a>📋 3️⃣ 环境与缓存变量</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(ENV&#123;PATH&#125; <span class="string">&quot;/extra/tools:$ENV&#123;PATH&#125;&quot;</span>)</span><br><span class="line"><span class="keyword">message</span>(<span class="string">&quot;PATH = $ENV&#123;PATH&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(VERSION_TAG <span class="string">&quot;v1&quot;</span> CACHE <span class="keyword">STRING</span> <span class="string">&quot;project version&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>📘 CACHE 会写入 <code>CMakeCache.txt</code>，下次 cmake 保留。</p>
<hr>
<h2 id="🧮-4️⃣-列表与操作"><a href="#🧮-4️⃣-列表与操作" class="headerlink" title="🧮 4️⃣ 列表与操作"></a>🧮 4️⃣ 列表与操作</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(MYLIST A B C)</span><br><span class="line"><span class="keyword">list</span>(APPEND MYLIST D)</span><br><span class="line"><span class="keyword">foreach</span>(item IN LISTS MYLIST)</span><br><span class="line">  <span class="keyword">message</span>(<span class="variable">$&#123;item&#125;</span>)</span><br><span class="line"><span class="keyword">endforeach</span>()</span><br></pre></td></tr></table></figure>

<p>字符串：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span>(REPLACE <span class="string">&quot;;&quot;</span> <span class="string">&quot;,&quot;</span> OUTPUT <span class="string">&quot;$&#123;MYLIST&#125;&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="⚙️-第二章：构建目标-Targets-与命名空间"><a href="#⚙️-第二章：构建目标-Targets-与命名空间" class="headerlink" title="⚙️ 第二章：构建目标(Targets) 与命名空间"></a>⚙️ 第二章：构建目标(Targets) 与命名空间</h1><hr>
<h2 id="🧩-Target-是什么？"><a href="#🧩-Target-是什么？" class="headerlink" title="🧩 Target 是什么？"></a>🧩 Target 是什么？</h2><blockquote>
<p>每个 <code>add_library()</code> 或 <code>add_executable()</code> 创建的实体目标是一个 <strong>Target</strong>。<br>一切引用、依赖、安装都绕着 Target 进行。</p>
</blockquote>
<p>例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Core STATIC core.cpp)</span><br><span class="line"><span class="keyword">add_executable</span>(App main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(App PRIVATE Core)</span><br></pre></td></tr></table></figure>

<p>📘 <code>&quot;App&quot;</code> 目标链接 <code>&quot;Core&quot;</code>。</p>
<blockquote>
<p>Target 与变量不同，它是 CMake 内部的“构建对象”。</p>
</blockquote>
<hr>
<h2 id="💡-target-link-libraries-的三修饰符"><a href="#💡-target-link-libraries-的三修饰符" class="headerlink" title="💡 target_link_libraries 的三修饰符"></a>💡 target_link_libraries 的三修饰符</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(App</span><br><span class="line">    PRIVATE Core</span><br><span class="line">    PUBLIC OpenCV::opencv_core</span><br><span class="line">    INTERFACE Boost::boost)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>修饰符</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>PRIVATE</td>
<td>仅 App 编译需要 Core 的头文件，不传播</td>
</tr>
<tr>
<td>PUBLIC</td>
<td>App 和依赖 App 的目标都要用</td>
</tr>
<tr>
<td>INTERFACE</td>
<td>当前目标不需要，但下游要用（多用于 header-only 库）</td>
</tr>
</tbody></table>
<hr>
<h2 id="🌐-命名空间（Namespace）是什么？"><a href="#🌐-命名空间（Namespace）是什么？" class="headerlink" title="🌐 命名空间（Namespace）是什么？"></a>🌐 命名空间（Namespace）是什么？</h2><p><code>OpenCV::opencv_core</code> 其实是外部库 <code>OpenCV</code> 安装时导出的命名空间前缀。<br><code>find_package(OpenCV)</code> 返回的就是一系列 Target，如：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">OpenCV::core</span><br><span class="line">OpenCV::imgproc</span><br><span class="line">OpenCV::highgui</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;&gt; 它不是变量，而是<strong>target 名称空间引用</strong>。<br>在 <em>install(EXPORT)</em> 生成 Config 中我们也能自定义自己的命名空间。</p>
<hr>
<h1 id="🧰-第三章：install-与-export-机制"><a href="#🧰-第三章：install-与-export-机制" class="headerlink" title="🧰 第三章：install 与 export 机制"></a>🧰 第三章：install 与 export 机制</h1><hr>
<h2 id="🧩-install-TARGETS-…-是装什么？"><a href="#🧩-install-TARGETS-…-是装什么？" class="headerlink" title="🧩 install(TARGETS …) 是装什么？"></a>🧩 install(TARGETS …) 是装什么？</h2><p>用于复制编译好的目标到指定安装目录。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(TARGETS Core</span><br><span class="line">  RUNTIME DESTINATION bin</span><br><span class="line">  LIBRARY DESTINATION lib</span><br><span class="line">  ARCHIVE DESTINATION lib</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>类型</th>
<th>对应</th>
<th>平台差异</th>
</tr>
</thead>
<tbody><tr>
<td>RUNTIME</td>
<td><code>.exe/.so</code> 可执行文件</td>
<td>Windows&#x2F;Linux 共用</td>
</tr>
<tr>
<td>LIBRARY</td>
<td>动态库 <code>.so/.dll</code></td>
<td>-</td>
</tr>
<tr>
<td>ARCHIVE</td>
<td>静态库 <code>.a/.lib</code></td>
<td>-</td>
</tr>
</tbody></table>
<hr>
<h2 id="📦-install-EXPORT-…-到底干嘛"><a href="#📦-install-EXPORT-…-到底干嘛" class="headerlink" title="📦 install(EXPORT …) 到底干嘛"></a>📦 install(EXPORT …) 到底干嘛</h2><p>这是导出一份 “<strong>目标描述文件</strong>”。<br>举例：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  <span class="keyword">FILE</span> MyProjectConfig.cmake</span><br><span class="line">  NAMESPACE MyProject::</span><br><span class="line">  DESTINATION lib/cmake/MyProject</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>在项目安装阶段会生成：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install/lib/cmake/MyProject/MyProjectConfig.cmake</span><br></pre></td></tr></table></figure></li>
<li>里面记录了所有通过 <code>install(TARGETS ... EXPORT MyProjectTargets)</code> 注册过的 target。</li>
<li>之后外部工程就可以：<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MyProject REQUIRED)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(OtherApp MyProject::Core)</span><br></pre></td></tr></table></figure>
来快速使用你的库。</li>
</ul>
<p>🪶 <strong>所以：</strong><br>1️⃣ <code>MyProjectTargets</code> 名是随便取的导出清单名；<br>2️⃣ 该清单由 install(TARGETS … EXPORT XXX) 收集形成；<br>3️⃣ 最终写入 Config 文件；<br>4️⃣ 命名空间只是一种前缀约定，通常和工程名一致。</p>
<hr>
<h1 id="🧩-第四章：find-package-用法实例"><a href="#🧩-第四章：find-package-用法实例" class="headerlink" title="🧩 第四章：find_package 用法实例"></a>🧩 第四章：find_package 用法实例</h1><hr>
<h2 id="✅-查找系统库"><a href="#✅-查找系统库" class="headerlink" title="✅ 查找系统库"></a>✅ 查找系统库</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;OpenCV_INCLUDE_DIRS&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(App PRIVATE <span class="variable">$&#123;OpenCV_LIBS&#125;</span>)</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>旧写法（兼容非现代导出库）：使用 <code>_INCLUDE_DIRS</code> <code>_LIBS</code> 变量；</li>
<li>新写法：<code>target_link_libraries(App PRIVATE OpenCV::core)</code> ，这种依赖查找 <strong>需要 OpenCV 自身提供导出的 CMake 配置文件</strong>。</li>
</ul>
<hr>
<h2 id="✅-自定义-FindXXX-cmake"><a href="#✅-自定义-FindXXX-cmake" class="headerlink" title="✅ 自定义 FindXXX.cmake"></a>✅ 自定义 FindXXX.cmake</h2><p>若库未提供Config，可自己写 <code>FindXxx.cmake</code> 并放入 <code>cmake/Modules/</code>。</p>
<p>路径查找：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span>(OpenCV_DIR <span class="string">&quot;/opt/opencv/lib/cmake/opencv4&quot;</span>)</span><br><span class="line"><span class="keyword">find_package</span>(OpenCV REQUIRED)</span><br></pre></td></tr></table></figure>

<p>这样 cmake 会去那个路径下找 <code>OpenCVConfig.cmake</code>。</p>
<hr>
<h1 id="🛠️-第五章：option-配置及-if-条件用法"><a href="#🛠️-第五章：option-配置及-if-条件用法" class="headerlink" title="🛠️ 第五章：option&#x2F;配置及 if 条件用法"></a>🛠️ 第五章：option&#x2F;配置及 if 条件用法</h1><hr>
<h2 id="⚙️-定义开关"><a href="#⚙️-定义开关" class="headerlink" title="⚙️ 定义开关"></a>⚙️ 定义开关</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">option</span>(BUILD_SHARED_LIBS <span class="string">&quot;Build shared libraries&quot;</span> <span class="keyword">ON</span>)</span><br></pre></td></tr></table></figure>

<p>这会出现在 CMake GUI &#x2F; cache，可在命令行修改：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DBUILD_SHARED_LIBS=OFF ..</span><br></pre></td></tr></table></figure>

<p>系统内置的常见 option：</p>
<table>
<thead>
<tr>
<th>变量</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>CMAKE_BUILD_TYPE</code></td>
<td>指定 Debug&#x2F;Release</td>
</tr>
<tr>
<td><code>CMAKE_VERBOSE_MAKEFILE</code></td>
<td>打印构建详细命令</td>
</tr>
<tr>
<td><code>BUILD_SHARED_LIBS</code></td>
<td>控制默认库类型</td>
</tr>
<tr>
<td><code>CMAKE_INSTALL_PREFIX</code></td>
<td>安装前缀</td>
</tr>
</tbody></table>
<hr>
<h1 id="🔧-第六章：file-命令详解（GLOB等）"><a href="#🔧-第六章：file-命令详解（GLOB等）" class="headerlink" title="🔧 第六章：file() 命令详解（GLOB等）"></a>🔧 第六章：file() 命令详解（GLOB等）</h1><hr>
<h2 id="📂-file-GLOB-…-指令"><a href="#📂-file-GLOB-…-指令" class="headerlink" title="📂 file(GLOB …) 指令"></a>📂 file(GLOB …) 指令</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(GLOB SRC_FILES <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/*.cpp&quot;</span>)</span><br><span class="line"><span class="keyword">add_library</span>(MyLib <span class="variable">$&#123;SRC_FILES&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>GLOB 用于通配符收集文件；</li>
<li>不会自动检测新增文件；</li>
<li>通常不建议用在正式项目（因为新增源文件后不会触发重新配置）；</li>
<li>推荐<strong>显式列出源码文件</strong>。</li>
</ul>
<p>还可用：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">file</span>(<span class="keyword">MAKE_DIRECTORY</span> build/output)     <span class="comment"># 创建目录</span></span><br><span class="line"><span class="keyword">file</span>(<span class="keyword">REMOVE</span> old.txt)                  <span class="comment"># 删除</span></span><br><span class="line"><span class="keyword">file</span>(READ path OUTPUT)                <span class="comment"># 读文件</span></span><br><span class="line"><span class="keyword">file</span>(WRITE path <span class="string">&quot;content&quot;</span>)            <span class="comment"># 写文件</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🚀-第七章：CMake-CLI-全功能表（带例子）"><a href="#🚀-第七章：CMake-CLI-全功能表（带例子）" class="headerlink" title="🚀 第七章：CMake CLI 全功能表（带例子）"></a>🚀 第七章：CMake CLI 全功能表（带例子）</h1><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td><code>cmake -S &lt;src&gt; -B &lt;build&gt;</code></td>
<td>指定源码与构建目录</td>
<td><code>cmake -S . -B build</code></td>
</tr>
<tr>
<td><code>cmake --build &lt;dir&gt; --target &lt;t&gt;</code></td>
<td>构建目标</td>
<td><code>cmake --build build --target App</code></td>
</tr>
<tr>
<td><code>cmake --install &lt;dir&gt; --prefix &lt;path&gt;</code></td>
<td>执行 install 阶段</td>
<td><code>cmake --install build --prefix ./release</code></td>
</tr>
<tr>
<td><code>ctest</code></td>
<td>运行测试</td>
<td><code>ctest --output-on-failure</code></td>
</tr>
<tr>
<td><code>cpack</code></td>
<td>打包(使用CPack配置)</td>
<td><code>cpack -G TGZ -C Release</code></td>
</tr>
<tr>
<td><code>cmake -DVAR=value</code></td>
<td>定义变量</td>
<td><code>cmake -DBUILD_TESTS=ON ..</code></td>
</tr>
<tr>
<td><code>cmake -G &quot;Ninja&quot;</code></td>
<td>指定生成器</td>
<td><code>cmake -G &quot;Unix Makefiles&quot;</code></td>
</tr>
</tbody></table>
<hr>
<h1 id="🧱-第八章：完整工程化模板逐行注释版（强化理解）"><a href="#🧱-第八章：完整工程化模板逐行注释版（强化理解）" class="headerlink" title="🧱 第八章：完整工程化模板逐行注释版（强化理解）"></a>🧱 第八章：完整工程化模板逐行注释版（强化理解）</h1><p>目录结构（带第三方、导出宏、pimpl）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MyProject/</span><br><span class="line">├─ Core/</span><br><span class="line">│  ├─ core.h core.cpp</span><br><span class="line">│  ├─ core_export.h</span><br><span class="line">│  └─ CMakeLists.txt</span><br><span class="line">├─ Net/</span><br><span class="line">│  ├─ net.h/net.cpp/net_export.h</span><br><span class="line">│  └─ CMakeLists.txt</span><br><span class="line">├─ App/</span><br><span class="line">│  ├─ main.cpp</span><br><span class="line">│  └─ CMakeLists.txt</span><br><span class="line">├─ include/        # 统一安装头</span><br><span class="line">├─ cmake/</span><br><span class="line">│  └─ FindFMT.cmake</span><br><span class="line">└─ CMakeLists.txt</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-顶层-CMakeLists-txt（讲解版）"><a href="#🔹-顶层-CMakeLists-txt（讲解版）" class="headerlink" title="🔹 顶层 CMakeLists.txt（讲解版）"></a>🔹 顶层 CMakeLists.txt（讲解版）</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.20</span>)</span><br><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span> LANGUAGES CXX)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"><span class="keyword">set</span>(CMAKE_RUNTIME_OUTPUT_DIRECTORY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局安装路径</span></span><br><span class="line"><span class="keyword">include</span>(GNUInstallDirs)  <span class="comment"># 提供 $&#123;CMAKE_INSTALL_LIBDIR&#125;, $&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依赖第三方 Header-only 库 fmt</span></span><br><span class="line"><span class="keyword">find_package</span>(fmt REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_subdirectory</span>(Core)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(Net)</span><br><span class="line"><span class="keyword">add_subdirectory</span>(App)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出所有目标描述文件（为 SDK 使用做准备）</span></span><br><span class="line"><span class="keyword">install</span>(<span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">    <span class="keyword">FILE</span> MyProjectConfig.cmake</span><br><span class="line">    NAMESPACE MyProject::</span><br><span class="line">    DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span>/cmake/MyProject)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-Core-模块"><a href="#🔹-Core-模块" class="headerlink" title="🔹 Core 模块"></a>🔹 Core 模块</h2><p><strong>core_export.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(_WIN32)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">if</span> defined(CORE_EXPORTS)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CORE_API __declspec(dllexport)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> CORE_API __declspec(dllimport)</span></span><br><span class="line">  <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">define</span> CORE_API</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p><strong>core.h &#x2F; core.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core_export.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CORE_API</span> Core &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Core</span>();</span><br><span class="line">  ~<span class="built_in">Core</span>();</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">hello</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Impl</span>;</span><br><span class="line">  std::unique_ptr&lt;Impl&gt; pImpl; <span class="comment">// Pimpl隔离ABI</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>core.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;core.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Core</span>::Impl &#123; <span class="function"><span class="type">void</span> <span class="title">say</span><span class="params">()</span></span>&#123; std::cout&lt;&lt;<span class="string">&quot;Hello Core\n&quot;</span>; &#125; &#125;;</span><br><span class="line">Core::<span class="built_in">Core</span>() : <span class="built_in">pImpl</span>(std::<span class="built_in">make_unique</span>&lt;Impl&gt;()) &#123;&#125;</span><br><span class="line">Core::~<span class="built_in">Core</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Core::hello</span><span class="params">()</span> <span class="type">const</span> </span>&#123; pImpl-&gt;<span class="built_in">say</span>(); &#125;</span><br></pre></td></tr></table></figure>

<p><strong>CMakeLists.txt</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Core SHARED core.cpp)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Core PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(Core PRIVATE CORE_EXPORTS)</span><br><span class="line"><span class="keyword">install</span>(TARGETS Core <span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  LIBRARY DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">  ARCHIVE DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">  PUBLIC_HEADER DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>/Core)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-Net-模块示例（依赖-Core-fmt）"><a href="#🔹-Net-模块示例（依赖-Core-fmt）" class="headerlink" title="🔹 Net 模块示例（依赖 Core + fmt）"></a>🔹 Net 模块示例（依赖 Core + fmt）</h2><p><strong>CMakeLists.txt</strong></p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(Net SHARED net.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(Net PUBLIC Core fmt::fmt)</span><br><span class="line"><span class="keyword">target_include_directories</span>(Net PUBLIC <span class="variable">$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;</span>)</span><br><span class="line"><span class="keyword">target_compile_definitions</span>(Net PRIVATE NET_EXPORTS)</span><br><span class="line"><span class="keyword">install</span>(TARGETS Net <span class="keyword">EXPORT</span> MyProjectTargets</span><br><span class="line">  LIBRARY DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_LIBDIR&#125;</span></span><br><span class="line">  PUBLIC_HEADER DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_INCLUDEDIR&#125;</span>/Net)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>net.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fmt/core.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Net::connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fmt::<span class="built_in">print</span>(<span class="string">&quot;Net connecting...\n&quot;</span>);</span><br><span class="line">  Core core;</span><br><span class="line">  core.<span class="built_in">hello</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="🔹-App-模块"><a href="#🔹-App-模块" class="headerlink" title="🔹 App 模块"></a>🔹 App 模块</h2><figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(App main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(App PRIVATE Core Net)</span><br><span class="line"><span class="keyword">install</span>(TARGETS App RUNTIME DESTINATION <span class="variable">$&#123;CMAKE_INSTALL_BINDIR&#125;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;net.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; Net net; net.<span class="built_in">connect</span>(); &#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>✅ 编译流程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -S . -B build</span><br><span class="line">cmake --build build</span><br><span class="line">cmake --install build --prefix ./install</span><br></pre></td></tr></table></figure>

<p>安装产物：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">install/</span><br><span class="line">├─ bin/App</span><br><span class="line">├─ lib/libCore.so</span><br><span class="line">├─ lib/libNet.so</span><br><span class="line">├─ include/Core/core.h</span><br><span class="line">├─ include/Net/net.h</span><br><span class="line">└─ lib/cmake/MyProject/MyProjectConfig.cmake</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="🎁-小结"><a href="#🎁-小结" class="headerlink" title="🎁 小结"></a>🎁 小结</h1><p>这一套现在交代清楚了：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GLOB 干什么</td>
<td>通配文件名，不建议常用</td>
</tr>
<tr>
<td>TARGETS 是啥</td>
<td>add_library&#x2F;add_executable 创建的目标</td>
</tr>
<tr>
<td>MyProjTargets 从哪来</td>
<td>你随便命名的导出清单名，install 时生成 Config</td>
</tr>
<tr>
<td>OpenCV::OpenCV vs ${OpenCV_LIBS}</td>
<td>前者是现代 target 写法，后者旧式变量写法</td>
</tr>
<tr>
<td>option 是 CMake 内置，可自定义更多</td>
<td><code>option(NAME DESC DEFAULT)</code></td>
</tr>
<tr>
<td>install&#x2F;namespace 的意义</td>
<td>用于生成供外部 find_package 的 SDK</td>
</tr>
<tr>
<td>include 路径没见？</td>
<td>通过 target_include_directories 公布路径</td>
</tr>
<tr>
<td>模块导出宏？</td>
<td>已展示 core_export.h 写法</td>
</tr>
<tr>
<td>ABI 兼容？</td>
<td>采用 pimpl 已实现</td>
</tr>
<tr>
<td>SDK 引用？</td>
<td>find_package(MyProject REQUIRED) 后 link MyProject::Core</td>
</tr>
</tbody></table>
<hr>
]]></content>
  </entry>
  <entry>
    <title>PlantUML cheatsheet</title>
    <url>/PlantUML-cheatsheet/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="PlantUML-语法说明（语法-示例-说明-停顿-风险）"><a href="#PlantUML-语法说明（语法-示例-说明-停顿-风险）" class="headerlink" title="PlantUML 语法说明（语法 + 示例 + 说明 + 停顿&#x2F;风险）"></a>PlantUML 语法说明（语法 + 示例 + 说明 + 停顿&#x2F;风险）</h3><hr>
<h3 id="基础启动与退出"><a href="#基础启动与退出" class="headerlink" title="基础启动与退出"></a>基础启动与退出</h3><ul>
<li><p>语法<br>@startuml … @enduml</p>
</li>
<li><p>示例<br>@startuml<br>Alice -&gt; Bob: hello<br>@enduml</p>
</li>
<li><p>说明<br>定界一个 PlantUML 图块，渲染工具会识别 @startuml 到 @enduml 之间的内容并生成图像。</p>
</li>
<li><p>停顿&#x2F;风险<br>忘记闭合 @enduml 会导致渲染失败或超时；在批量渲染脚本中务必校验每个文件完整性。</p>
</li>
<li><p>语法（文件包含）<br>!include <file></p>
</li>
<li><p>示例<br>!include common&#x2F;colors.puml</p>
</li>
<li><p>说明<br>将外部 puml 文件或库包含进当前图，用于复用样式&#x2F;宏。</p>
</li>
<li><p>停顿&#x2F;风险<br>包含不存在文件会报错；相对路径在渲染环境中可能不同，CI&#x2F;工具链中需使用绝对或一致的相对路径。</p>
</li>
</ul>
<hr>
<h3 id="图类型与启动模板（快速索引）"><a href="#图类型与启动模板（快速索引）" class="headerlink" title="图类型与启动模板（快速索引）"></a>图类型与启动模板（快速索引）</h3><ul>
<li><p>Sequence（时序图）<br>语法<br>participant A; participant B; A -&gt; B: msg<br>示例<br>@startuml<br>Alice -&gt; Bob: Hello<br>@enduml<br>说明<br>描述消息流与交互顺序。<br>停顿&#x2F;风险<br>大量消息会造成图像拥挤，必要时分片或用 note&#x2F;alt 分支简化。</p>
</li>
<li><p>Class（类图）<br>语法<br>class Name { +field; -method() }<br>示例<br>@startuml<br>class User {<br>  +id: int<br>  +login()<br>}<br>@enduml<br>说明<br>定义类、属性与方法，支持继承、接口、组合关系。<br>停顿&#x2F;风险<br>过度细化属性&#x2F;方法会使类图难读，按关注点抽象即可。</p>
</li>
<li><p>Activity（活动图）<br>语法<br>start; :action; if (cond) then (yes) :do; else (no) :skip; endif; stop<br>示例<br>@startuml<br>start<br>:initialize;<br>if (ok?) then (yes)<br>  :process;<br>else (no)<br>  :abort;<br>endif<br>stop<br>@enduml<br>说明<br>描述流程控制、分支与并行（fork&#x2F;merge）。<br>停顿&#x2F;风险<br>并行分支（fork&#x2F;merge）滥用会复杂化视图，需标注同步点。</p>
</li>
<li><p>State（状态图）<br>语法<br>[<em>] –&gt; State; State –&gt; AnotherState : event<br>示例<br>@startuml<br>[</em>] –&gt; Idle<br>Idle –&gt; Running : start<br>Running –&gt; Idle : stop<br>@enduml<br>说明<br>表示实体生命周期与事件触发的状态变迁。<br>停顿&#x2F;风险<br>状态过多要分层（state inside）以保持可读性。</p>
</li>
<li><p>Component &#x2F; Deployment（组件与部署）<br>语法<br>component A; node N; A -[#]-&gt; B;<br>示例<br>@startuml<br>node “Server” {<br>  component WebApp<br>}<br>component Database<br>WebApp –&gt; Database : JDBC<br>@enduml<br>说明<br>展示系统组件、网络与部署位置。<br>停顿&#x2F;风险<br>部署图含环境信息可能泄露敏感架构，发布前审查。</p>
</li>
<li><p>Usecase（用例图）<br>语法<br>actor User; usecase “Login” as UC1; User –&gt; UC1<br>示例<br>@startuml<br>actor Customer<br>Customer –&gt; (Place order)<br>@enduml<br>说明<br>高层次用户与系统功能映射。<br>停顿&#x2F;风险<br>用例图不适合展示实现细节，避免混用类图语义。</p>
</li>
</ul>
<hr>
<h3 id="元素语法与关系（常用速查）"><a href="#元素语法与关系（常用速查）" class="headerlink" title="元素语法与关系（常用速查）"></a>元素语法与关系（常用速查）</h3><ul>
<li><p>元素定义（参与者 &#x2F; 对象）<br>语法<br>participant Name; actor Name; object Name; boundary Name<br>示例<br>participant Service</p>
</li>
<li><p>说明<br>不同关键字影响图语义与样式（actor 常带人形图标）。</p>
</li>
<li><p>停顿&#x2F;风险<br>名称含空格时用引号或别名；重复定义会被合并或覆盖。</p>
</li>
<li><p>关系箭头（方向、类型、文本）<br>语法<br>A -&gt; B : msg ; A &lt;– B ; A -[#color]-&gt; B ; A ..&gt; B : note<br>示例<br>A –&gt; B : request</p>
</li>
<li><p>说明<br>箭头可表示同步&#x2F;异步调用、依赖、泛化（–|&gt;）等；可加颜色与样式。</p>
</li>
<li><p>停顿&#x2F;风险<br>复杂箭头嵌套会影响布局，必要时拆图或使用 left&#x2F;right 指令微调。</p>
</li>
<li><p>继承 &#x2F; 实现 &#x2F; 关联<br>语法<br>Child –|&gt; Parent; Impl ..|&gt; Interface</p>
</li>
<li><p>示例<br>Dog –|&gt; Animal</p>
</li>
<li><p>说明<br>使用 UML 标准箭头表示类之间的继承或实现关系。</p>
</li>
<li><p>停顿&#x2F;风险<br>误用箭头方向会导致语义反转，保持一致的方向约定。</p>
</li>
<li><p>注释与说明（note）<br>语法<br>note left of A : text ; note right of A ; note as N: text</p>
</li>
<li><p>示例<br>A -&gt; B : call<br>note right of B : validate input</p>
</li>
<li><p>说明<br>用于补充说明、注释或折叠复杂逻辑。</p>
</li>
<li><p>停顿&#x2F;风险<br>太多 note 会遮挡元素，优先用外部文档链接或图例。</p>
</li>
</ul>
<hr>
<h3 id="样式、布局与配置"><a href="#样式、布局与配置" class="headerlink" title="样式、布局与配置"></a>样式、布局与配置</h3><ul>
<li><p>全局皮肤参数（skinparam）<br>语法<br>skinparam Parameter Value</p>
</li>
<li><p>示例<br>skinparam backgroundColor #F8F8F8<br>skinparam classFontSize 12</p>
</li>
<li><p>说明<br>控制颜色、字体、边距、节点圆角等全局外观。</p>
</li>
<li><p>停顿&#x2F;风险<br>不同渲染器或版本对参数支持不一致；在团队中固定一套样式文件避免差异。</p>
</li>
<li><p>主题与样式表（!theme &#x2F; skinparam include）<br>语法<br>!include &lt;theme.puml&gt;</p>
</li>
<li><p>示例<br>!include <a href="https://raw.githubusercontent.com/xxx/theme.puml">https://raw.githubusercontent.com/xxx/theme.puml</a></p>
</li>
<li><p>说明<br>使用共享主题确保跨图一致性。</p>
</li>
<li><p>停顿&#x2F;风险<br>远程包含依赖网络，CI 环境中应缓存或 vendor 本地副本。</p>
</li>
<li><p>分组与包（package &#x2F; rectangle）<br>语法<br>package “Name” { … } ; rectangle “box” { … }</p>
</li>
<li><p>示例<br>package “Auth” {<br>  class Login<br>  class Token<br>}</p>
</li>
<li><p>说明<br>用于逻辑分组、模块边界或可视化分箱。</p>
</li>
<li><p>停顿&#x2F;风险<br>过深嵌套影响可读性；优先扁平化或拆分子图。</p>
</li>
<li><p>布局控制（left to right direction &#x2F; newpage）<br>语法<br>left to right direction ; top to bottom direction ; newpage</p>
</li>
<li><p>示例<br>left to right direction</p>
</li>
<li><p>说明<br>强制图元素主要排列方向或分页。</p>
</li>
<li><p>停顿&#x2F;风险<br>布局指令可能被局部元素大小覆盖，需配合组件分组调整。</p>
</li>
</ul>
<hr>
<h3 id="高级功能与脚本化"><a href="#高级功能与脚本化" class="headerlink" title="高级功能与脚本化"></a>高级功能与脚本化</h3><ul>
<li><p>条件 &#x2F; 分支（alt &#x2F; else &#x2F; end）——时序图分支<br>语法<br>alt condition1<br>  A -&gt; B: x<br>else<br>  A -&gt; B: y<br>end</p>
</li>
<li><p>示例<br>@startuml<br>Alice -&gt; Bob: request<br>alt success<br>  Bob -&gt; Alice: ok<br>else failure<br>  Bob -&gt; Alice: error<br>end<br>@enduml</p>
</li>
<li><p>说明<br>表示分支路径或替代流程。</p>
</li>
<li><p>停顿&#x2F;风险<br>嵌套太深会导致视觉复杂，考虑合并或拆图。</p>
</li>
<li><p>循环与重复（loop）<br>语法<br>loop description</p>
</li>
<li><p>示例<br>loop every second<br>  A -&gt; B: tick<br>end</p>
</li>
<li><p>说明<br>表示重复行为或周期性交互。</p>
</li>
<li><p>停顿&#x2F;风险<br>用于抽象，不要试图展示真实无限循环细节。</p>
</li>
<li><p>皮肤参数条件化&#x2F;宏（!define &#x2F; !if &#x2F; !endif）<br>语法<br>!define NAME value<br>!if NAME<br>!endif</p>
</li>
<li><p>示例<br>!define PROD<br>!if PROD<br>  skinparam backgroundColor #fff<br>!endif</p>
</li>
<li><p>说明<br>在生成时切换主题或启用选项，适合 CI 多环境渲染。</p>
</li>
<li><p>停顿&#x2F;风险<br>宏扩展错误会导致解析失败，先在本地验证。</p>
</li>
<li><p>布局微调（<backspace/> &#x2F; <size> &#x2F; order）<br>语法与示例<br>使用 skinparam 或隐藏标签调整元素尺寸、顺序或间距（具体参数见官方文档）。</p>
</li>
<li><p>说明<br>对复杂图必需进行微调。</p>
</li>
<li><p>停顿&#x2F;风险<br>各版本对微调支持不同，版本不一致会导致图像差异。</p>
</li>
<li><p>导出与命令行渲染<br>语法<br>plantuml -tsvg file.puml ; plantuml -tpng file.puml</p>
</li>
<li><p>示例<br>plantuml -tsvg diagram.puml</p>
</li>
<li><p>说明<br>在 CI&#x2F;脚本中常用命令行生成 PNG&#x2F;SVG&#x2F;PDF，支持并行渲染。</p>
</li>
<li><p>停顿&#x2F;风险<br>大量并发渲染可能耗尽内存&#x2F;CPU；加队列或并发限制。</p>
</li>
</ul>
<hr>
<h3 id="常用-alias、快捷组合与高危命令清单（模仿-GDB-Cheat-Sheet）"><a href="#常用-alias、快捷组合与高危命令清单（模仿-GDB-Cheat-Sheet）" class="headerlink" title="常用 alias、快捷组合与高危命令清单（模仿 GDB Cheat Sheet）"></a>常用 alias、快捷组合与高危命令清单（模仿 GDB Cheat Sheet）</h3><ul>
<li><p>常用快捷片段（可放入 .puml 或模板）  </p>
<ul>
<li>组件模板<br>skinparam componentStyle rectangle</li>
<li>标准页眉与版权<br>‘ Header: auto-generated</li>
<li>标注图例<br>legend left<br>  |&#x3D; Symbol |&#x3D; Meaning |<br>  | –&gt; | call |<br>endlegend</li>
</ul>
</li>
<li><p>说明<br>把常用片段抽成 include 文件便于复用。</p>
</li>
<li><p>停顿&#x2F;风险<br>模板变化会影响大量图，变更需审查。</p>
</li>
<li><p>高危指令（需谨慎）  </p>
<ul>
<li>!include 指向外部 URL：依赖网络和第三方代码，可能带来不受控变化或安全风险。  </li>
<li>过度宏定义（!define）与条件编译：增加调试复杂度与可维护性风险。  </li>
<li>绝对路径（!include &#x2F; skinparam 指向本地绝对路径）：在跨机器&#x2F;CI 中失效。  </li>
<li>大型单图（数千节点）：会导致渲染卡死或输出巨大文件，建议拆图或分层图。</li>
</ul>
</li>
<li><p>停顿&#x2F;风险<br>在生产文档中使用外部 include 前执行安全与版本审计；在 CI 中锁定模板版本。</p>
</li>
</ul>
<hr>
<h3 id="学习与心法附注（如何高效使用-PlantUML）"><a href="#学习与心法附注（如何高效使用-PlantUML）" class="headerlink" title="学习与心法附注（如何高效使用 PlantUML）"></a>学习与心法附注（如何高效使用 PlantUML）</h3><ul>
<li>先画大结构再细化：先确认图的目的与受众，避免把所有细节塞进一张图。  </li>
<li>抽象优先于精确：设计交付物是沟通工具而非精确模型，保留必要细节。  </li>
<li>模板化与复用：把皮肤参数、图例、常用组件抽成共享 include，保证风格一致性与维护性。  </li>
<li>自动化渲染：在 CI 中加入 lint 与渲染步骤，发现语法错误与样式回归。  </li>
<li>版本锁定：对外部 include 与主题进行版本管理，避免“今天可渲染、明天报错”的情况。  </li>
<li>安全与隐私：部署&#x2F;网络&#x2F;环境图请先脱敏，发布前审查所有外部依赖。</li>
</ul>
<hr>
<p>附：快速示例集合（可直接复制到 .puml）<br>@startuml<br>skinparam backgroundColor #F8F8F8<br>left to right direction</p>
<p>actor Customer<br>rectangle “WebApp” {<br>  component UI<br>  component “Auth Service” as Auth<br>}<br>database DB</p>
<p>Customer -&gt; UI: open page<br>UI -&gt; Auth: login(credentials)<br>Auth -&gt; DB: query user<br>Auth –&gt; UI: token<br>UI –&gt; Customer: success</p>
<p>@enduml</p>
<p>说明：复合示例包含 actor、component、database、箭头与全局 skinparam。停顿&#x2F;风险：示例为演示，不适合直接展示生产部署细节，请脱敏与分图表达。</p>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Graphviz cheatsheet</title>
    <url>/Graphviz-cheatsheet/</url>
    <content><![CDATA[<span id="more"></span>
<h1 id="Graphviz-语法速查文档（语法-示例-说明-停顿-风险）"><a href="#Graphviz-语法速查文档（语法-示例-说明-停顿-风险）" class="headerlink" title="Graphviz 语法速查文档（语法 + 示例 + 说明 + 停顿&#x2F;风险）"></a>Graphviz 语法速查文档（语法 + 示例 + 说明 + 停顿&#x2F;风险）</h1><p>概览：Graphviz 使用 DOT 语言描述图。核心是 graph&#x2F; digraph、node、edge、subgraph、attributes。下面按主题给出常用语法条目，每条包含「语法」「示例」「说明」「停顿&#x2F;风险」。</p>
<hr>
<h3 id="基本结构与启动"><a href="#基本结构与启动" class="headerlink" title="基本结构与启动"></a>基本结构与启动</h3><ul>
<li><p>语法<br>graph 名称 { … }<br>digraph 名称 { … }</p>
</li>
<li><p>示例<br>digraph G {<br>  A -&gt; B;<br>}</p>
</li>
<li><p>说明<br>graph 用于无向图（使用 –），digraph 用于有向图（使用 -&gt;）。块内放节点、边、属性与子图。  </p>
</li>
<li><p>停顿&#x2F;风险<br>忘记分号可能被允许但会引起解析歧义；严格遵守括号配对，缺少闭合会导致渲染失败。</p>
</li>
<li><p>命令行渲染<br>dot -Tpng in.dot -o out.png</p>
</li>
<li><p>示例<br>dot -Tsvg diagram.dot -o diagram.svg</p>
</li>
<li><p>说明<br>dot&#x2F;neato&#x2F;fdp&#x2F;twopi&#x2F;sfdp&#x2F;osage 等为不同布局引擎，-T 指定输出格式。  </p>
</li>
<li><p>停顿&#x2F;风险<br>选择错误布局引擎会使大图不可读或耗时显著，批量渲染注意资源限制。</p>
</li>
</ul>
<hr>
<h3 id="节点与边基础"><a href="#节点与边基础" class="headerlink" title="节点与边基础"></a>节点与边基础</h3><ul>
<li><p>节点定义（隐式与显式）<br>语法<br>A;<br>A [label&#x3D;”User”, shape&#x3D;box];</p>
</li>
<li><p>示例<br>node1 [label&#x3D;”DB”, shape&#x3D;component];</p>
</li>
<li><p>说明<br>未显式定义的标识符在第一次用于边时自动创建。attributes 控制外观与行为。  </p>
</li>
<li><p>停顿&#x2F;风险<br>节点名含特殊字符或空格需用引号或用 label 保证可读性；大小写敏感。</p>
</li>
<li><p>边语法（无向&#x2F;有向）<br>语法<br>A – B;   (无向)<br>A -&gt; B;   (有向)</p>
</li>
<li><p>示例<br>A -&gt; B [label&#x3D;”req”, color&#x3D;blue];</p>
</li>
<li><p>说明<br>边可以带属性（label、color、style、taillabel&#x2F;headlabel、arrowhead 等）。  </p>
</li>
<li><p>停顿&#x2F;风险<br>在 digraph 中使用 – 会被接受但语义混淆，保持一致使用 -&gt;。</p>
</li>
<li><p>多端&#x2F;复合边<br>语法<br>A -&gt; {B C D};  </p>
</li>
<li><p>示例<br>Service -&gt; {DB Cache};</p>
</li>
<li><p>说明<br>批量连接的简写，等价于多条独立边。  </p>
</li>
<li><p>停顿&#x2F;风险<br>对属性的作用域需注意：放在集合后面的属性通常应用到所有隐式生成的边。</p>
</li>
</ul>
<hr>
<h3 id="属性系统（节点-边-图）"><a href="#属性系统（节点-边-图）" class="headerlink" title="属性系统（节点&#x2F;边&#x2F;图）"></a>属性系统（节点&#x2F;边&#x2F;图）</h3><ul>
<li><p>通用语法<br>target [attr1&#x3D;value1, attr2&#x3D;value2];<br>graph [splines&#x3D;true]; node [shape&#x3D;box];</p>
</li>
<li><p>示例<br>graph [rankdir&#x3D;LR, fontsize&#x3D;12];<br>node [shape&#x3D;ellipse, color&#x3D;”#333333”];</p>
</li>
<li><p>说明<br>graph、node、edge 的裸属性会作为默认值应用到图中相应元素。支持字符串、颜色、布尔值。  </p>
</li>
<li><p>停顿&#x2F;风险<br>不同渲染器对属性支持不同（如 HTML 标签、gradient），在跨环境渲染前验证。</p>
</li>
<li><p>常用属性速查  </p>
<ul>
<li>label: 显示文字  </li>
<li>shape: box, ellipse, record, plaintext, circle, component 等  </li>
<li>style: filled, dashed, bold, invis  </li>
<li>color &#x2F; fillcolor &#x2F; fontcolor  </li>
<li>fontsize &#x2F; fontname  </li>
<li>rankdir: LR, TB, RL, BT（方向）  </li>
<li>splines: true|false|curved|ortho（边路由）  </li>
<li>rank: same|min|max（节点纵向对齐）</li>
</ul>
</li>
<li><p>示例<br>edge [arrowhead&#x3D;vee, color&#x3D;gray];</p>
</li>
<li><p>停顿&#x2F;风险<br>颜色代码与字体在目标环境可能不可用或替换，最好指定安全的 web 颜色与常见字体。</p>
</li>
</ul>
<hr>
<h3 id="子图、Cluster-与层级布局"><a href="#子图、Cluster-与层级布局" class="headerlink" title="子图、Cluster 与层级布局"></a>子图、Cluster 与层级布局</h3><ul>
<li><p>基本子图语法<br>subgraph name { … }  </p>
</li>
<li><p>示例<br>subgraph cluster_0 {<br>  label&#x3D;”Auth”;<br>  A; B;<br>  A -&gt; B;<br>}</p>
</li>
<li><p>说明<br>使用 cluster_ 前缀会把子图渲染为带边框的聚簇（cluster），常用于模块&#x2F;场域分组。子图可含属性（label、style）。  </p>
</li>
<li><p>停顿&#x2F;风险<br>cluster 名称最好以 cluster_ 开头；错误的子图嵌套或属性放置会改变布局预期。</p>
</li>
<li><p>控制 rank（同层对齐）<br>语法<br>{ rank &#x3D; same; A; B; }</p>
</li>
<li><p>示例<br>{ rank &#x3D; same; UI; API; DB; }</p>
</li>
<li><p>说明<br>强制这些节点处于同一“等级”行&#x2F;列（受 rankdir 影响）。  </p>
</li>
<li><p>停顿&#x2F;风险<br>过多 rank 约束会与自动布局冲突，使布局变形或不可读。</p>
</li>
</ul>
<hr>
<h3 id="端口、记录节点与-HTML-标签"><a href="#端口、记录节点与-HTML-标签" class="headerlink" title="端口、记录节点与 HTML 标签"></a>端口、记录节点与 HTML 标签</h3><ul>
<li><p>端口语法（记录型节点）<br>语法<br>node:port 或 “node”:”port”<br>使用 record shape: {left|mid|right}</p>
</li>
<li><p>示例<br>node1 [shape&#x3D;record, label&#x3D;”{left|mid|right}”];<br>node1:left -&gt; node2;</p>
</li>
<li><p>说明<br>记录（record）节点允许分区并对准边的端口，适合显示结构化组件或数据字段。  </p>
</li>
<li><p>停顿&#x2F;风险<br>记录标签语法对引号、花括号敏感，复杂文本需用转义或 HTML 标签。</p>
</li>
<li><p>HTML-like 标签（富文本 label）<br>语法<br>label&#x3D;&lt;<table><tr><td>…</td></tr></table>&gt;  </p>
</li>
<li><p>示例<br>node [label&#x3D;&lt;<b>Service</b><br/>v1&gt;&gt;, shape&#x3D;plaintext];</p>
</li>
<li><p>说明<br>使用 HTML-like 标签进行复杂格式化（表格、粗体、换行）。并非所有输出&#x2F;渲染器对所有标签完全支持。  </p>
</li>
<li><p>停顿&#x2F;风险<br>HTML label 中的大小写或不闭合标签会导致解析错误；SVG 输出在不同渲染器下样式可能不同。</p>
</li>
</ul>
<hr>
<h3 id="布局引擎与高级控制"><a href="#布局引擎与高级控制" class="headerlink" title="布局引擎与高级控制"></a>布局引擎与高级控制</h3><ul>
<li><p>常见布局引擎<br>dot（层次布局，适合有向图）<br>neato&#x2F;fdp&#x2F;sfdp（基于力导向，适合无向&#x2F;大图）<br>twopi（径向布局）<br>circo（圆形布局）</p>
</li>
<li><p>命令行示例<br>neato -Tpng graph.dot -o graph.png</p>
</li>
<li><p>说明<br>选对引擎能显著改善可读性：dot 适合流程&#x2F;层级，sfdp 适合数千节点的大图。  </p>
</li>
<li><p>停顿&#x2F;风险<br>不同引擎对相同 DOT 文件会产生完全不同的视觉结果；测试并选择最合适的引擎。</p>
</li>
<li><p>细粒度布局控制（pos &#x2F; constraint &#x2F; weight）  </p>
<ul>
<li>pos&#x3D;”x,y!”：固定节点位置（“!” 表示强制）  </li>
<li>edge [constraint&#x3D;false]：忽略边在层级计算中的约束  </li>
<li>weight：影响边在力导向布局中的牵引力</li>
</ul>
</li>
<li><p>示例<br>A [pos&#x3D;”0,0!”]; B [pos&#x3D;”1,0!”]; A -&gt; B [constraint&#x3D;false];</p>
</li>
<li><p>说明<br>可用于在混合手工与自动布局时微调位置。  </p>
</li>
<li><p>停顿&#x2F;风险<br>使用固定位置会关闭布局引擎的自动优化，跨输出尺寸时位置可能失真；慎用“!”强制位置。</p>
</li>
</ul>
<hr>
<h3 id="子图可视化技巧与常见陷阱"><a href="#子图可视化技巧与常见陷阱" class="headerlink" title="子图可视化技巧与常见陷阱"></a>子图可视化技巧与常见陷阱</h3><ul>
<li><p>分图（newpage &#x2F; compound 图）  </p>
<ul>
<li>newpage：将输出分页（仅部分工具支持）。  </li>
<li>compound&#x3D;true：允许边跨 cluster 并使用 lhead&#x2F;ltail 指定附着点。</li>
</ul>
</li>
<li><p>示例<br>graph [compound&#x3D;true]; A -&gt; B [lhead&#x3D;cluster_0];</p>
</li>
<li><p>说明<br>compound 有助于画跨模块的连接并把边附着到聚簇边界。  </p>
</li>
<li><p>停顿&#x2F;风险<br>compound 配置复杂，错误的 lhead&#x2F;ltail 会导致边不可见或布局混乱。</p>
</li>
<li><p>性能与规模考量  </p>
<ul>
<li>对于上千节点，优先 sfdp 并设置 overlap&#x3D;false、nodesep、ranksep 等缩放参数。  </li>
<li>使用子图分层或分页导出以避免单图渲染失败。</li>
</ul>
</li>
<li><p>停顿&#x2F;风险<br>大图渲染可能耗尽内存或超时，在 CI 中并行渲染需限速。</p>
</li>
</ul>
<hr>
<h3 id="常用属性速查列表（快速参考）"><a href="#常用属性速查列表（快速参考）" class="headerlink" title="常用属性速查列表（快速参考）"></a>常用属性速查列表（快速参考）</h3><ul>
<li>graph: rankdir, bgcolor, splines, compound, overlap  </li>
<li>node: shape, label, style, color, fillcolor, fontsize, fontname, width, height  </li>
<li>edge: label, color, style, arrowhead, arrowtail, dir, minlen, constraint, weight, headlabel, taillabel  </li>
<li>布局: pos, rank, rankdir, nodesep, ranksep, margin</li>
</ul>
<p>示例（组合）<br>digraph G {<br>  graph [rankdir&#x3D;LR, splines&#x3D;ortho];<br>  node [shape&#x3D;record, fontsize&#x3D;11];<br>  A [label&#x3D;”{Req|id:int|data}”];<br>  B [label&#x3D;”<f0>left|<f1>right”, shape&#x3D;record];<br>  A:f1 -&gt; B:f0 [label&#x3D;”map”, color&#x3D;”#0066cc”];<br>}</p>
<p>停顿&#x2F;风险<br>属性相互作用复杂，先在小样例中验证每个属性的视觉效果再用于生产图。</p>
<hr>
<h3 id="常见坑与最佳实践"><a href="#常见坑与最佳实践" class="headerlink" title="常见坑与最佳实践"></a>常见坑与最佳实践</h3><ul>
<li>坑：不同 Graphviz 版本&#x2F;平台对属性支持不同。<br>最佳实践：在目标渲染环境中锁定 Graphviz 版本并测试样式库。</li>
<li>坑：使用外部字体或本地图片会导致渲染环境不可复现。<br>最佳实践：依赖通用字体或将资源内嵌&#x2F;打包到 CI。</li>
<li>坑：过度使用 HTML labels 或复杂 record 导致可访问性差。<br>最佳实践：为复杂视图提供纯文本替代或生成说明文档。</li>
<li>坑：在线嵌入（如 Markdown 渲染器）与本地 dot 行为不一致。<br>最佳实践：维护一套「可在目标平台直接渲染的最小 DOT 示例」。</li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Mermaid cheatsheet</title>
    <url>/Mermaid-cheatsheet/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="Mermaid-语法速查文档（语法-示例-说明-停顿-风险）"><a href="#Mermaid-语法速查文档（语法-示例-说明-停顿-风险）" class="headerlink" title="Mermaid 语法速查文档（语法 + 示例 + 说明 + 停顿&#x2F;风险）"></a>Mermaid 语法速查文档（语法 + 示例 + 说明 + 停顿&#x2F;风险）</h3><p>概览：Mermaid 是面向文档和前端渲染的轻量图表语言，常见于 Markdown、Wiki、Docs。支持 flowchart、sequence、class、state、gitgraph、pie、gantt、er 等图类型。下面按主题给出常用语法条目，每条包含「语法」「示例」「说明」「停顿&#x2F;风险」。</p>
<hr>
<h3 id="基本结构与渲染"><a href="#基本结构与渲染" class="headerlink" title="基本结构与渲染"></a>基本结构与渲染</h3><ul>
<li>语法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%% 开头可加注释</span><br><span class="line">graph LR</span><br><span class="line">  A--&gt;B</span><br></pre></td></tr></table></figure></li>
<li>示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">  A[Start] --&gt; B&#123;Is ok?&#125;</span><br><span class="line">  B -- Yes --&gt; C[Finish]</span><br><span class="line">  B -- No --&gt; D[Retry]</span><br></pre></td></tr></table></figure></li>
<li>说明<br>以图类型开头（graph, sequenceDiagram, classDiagram 等），随后的块为图定义。常见渲染环境：GitHub、GitLab、Mermaid Live Editor、Docs 工具链和 VSCode 插件。  </li>
<li>停顿&#x2F;风险<br>不同平台的 Mermaid 版本差异较大（语法扩展与主题支持不同），在目标平台上验证非常必要。</li>
</ul>
<hr>
<h3 id="流程图（flowchart-graph）"><a href="#流程图（flowchart-graph）" class="headerlink" title="流程图（flowchart &#x2F; graph）"></a>流程图（flowchart &#x2F; graph）</h3><ul>
<li><p>语法（方向、节点、边）  </p>
<ul>
<li>方向：graph LR&#x2F;TD&#x2F;BT&#x2F;RL（Left→Right &#x2F; Top→Down 等）  </li>
<li>节点：A[Label], A((Circle)), A&gt;parens], A[[database]]  </li>
<li>边：A –&gt; B, A -.-&gt; B, A &#x3D;&#x3D;&gt; B, A — B</li>
</ul>
</li>
<li><p>示例  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  Start([Start]) --&gt; Step1&#123;Check?&#125;</span><br><span class="line">  Step1 -- yes --&gt; Step2[Do it]</span><br><span class="line">  Step1 -- no --&gt; End([End])</span><br><span class="line">  Step2 --&gt; End</span><br></pre></td></tr></table></figure></li>
<li><p>说明<br>丰富的节点形状通过不同括号语法实现；边支持样式（实线、点线、加箭头样式）。  </p>
</li>
<li><p>停顿&#x2F;风险<br>节点名称不能含空格（可用引号或方括号 label），过多节点会触发布局拥挤，建议拆分或使用 subgraph。</p>
</li>
<li><p>子图（分组）<br>语法&#x2F;示例  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">subgraph Auth</span><br><span class="line">  A --&gt; B</span><br><span class="line">end</span><br></pre></td></tr></table></figure></li>
<li><p>说明<br>subgraph 用于视觉分组或模块化。  </p>
</li>
<li><p>停顿&#x2F;风险<br>subgraph 嵌套和方向继承可能导致布局与预期不同，注意写法与缩进。</p>
</li>
</ul>
<hr>
<h3 id="时序图（sequenceDiagram）"><a href="#时序图（sequenceDiagram）" class="headerlink" title="时序图（sequenceDiagram）"></a>时序图（sequenceDiagram）</h3><ul>
<li>语法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">  participant Alice</span><br><span class="line">  participant Bob</span><br><span class="line">  Alice-&gt;&gt;Bob: Hello</span><br><span class="line">  Bob--&gt;&gt;Alice: Hi</span><br></pre></td></tr></table></figure></li>
<li>示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">  Alice-&gt;&gt;+Bob: request</span><br><span class="line">  Bob--&gt;&gt;-Alice: response</span><br></pre></td></tr></table></figure></li>
<li>说明<br>支持参与者声明、同步&#x2F;异步箭头、激活（+ &#x2F; -）、注释、alt&#x2F;opt&#x2F;loop 分支等结构化控制。  </li>
<li>停顿&#x2F;风险<br>复杂分支深度对渲染器要求高；不同实现对 alt&#x2F;opt 的支持细节不同，分支标签要简洁。</li>
</ul>
<hr>
<h3 id="类图（classDiagram）"><a href="#类图（classDiagram）" class="headerlink" title="类图（classDiagram）"></a>类图（classDiagram）</h3><ul>
<li>语法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  class A &#123;</span><br><span class="line">    +int id</span><br><span class="line">    +do()</span><br><span class="line">  &#125;</span><br><span class="line">  A &lt;|-- B</span><br></pre></td></tr></table></figure></li>
<li>示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  Animal &lt;|-- Dog</span><br><span class="line">  Animal : +name</span><br><span class="line">  Dog : +bark()</span><br></pre></td></tr></table></figure></li>
<li>说明<br>表示类、属性、方法、继承和关联；支持接口与注释。  </li>
<li>停顿&#x2F;风险<br>Mermaid 的类图功能较 PlantUML 简略，复杂 UML 表达可能无法覆盖，选择时确认需求。</li>
</ul>
<hr>
<h3 id="状态图（stateDiagram-v2）"><a href="#状态图（stateDiagram-v2）" class="headerlink" title="状态图（stateDiagram-v2）"></a>状态图（stateDiagram-v2）</h3><ul>
<li>语法  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">  [*] --&gt; Idle</span><br><span class="line">  Idle --&gt; Running : start</span><br><span class="line">  Running --&gt; Idle : stop</span><br></pre></td></tr></table></figure></li>
<li>示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">stateDiagram-v2</span><br><span class="line">  state &quot;Processing&quot; as P &#123;</span><br><span class="line">    S1 --&gt; S2</span><br><span class="line">  &#125;</span><br><span class="line">  [*] --&gt; P</span><br></pre></td></tr></table></figure></li>
<li>说明<br>支持复合状态、并行、入口&#x2F;出口点与事件标注。  </li>
<li>停顿&#x2F;风险<br>并行状态（fork&#x2F;merge）在不同渲染版本表现不同，注意测试。</li>
</ul>
<hr>
<h3 id="ER-图与-Git-Graph、Gantt-等"><a href="#ER-图与-Git-Graph、Gantt-等" class="headerlink" title="ER 图与 Git Graph、Gantt 等"></a>ER 图与 Git Graph、Gantt 等</h3><ul>
<li>ER 图（实体关系）语法示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">  CUSTOMER ||--o&#123; ORDER : places</span><br><span class="line">  CUSTOMER &#123;</span><br><span class="line">    string name</span><br><span class="line">    int id</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>Git Graph 简单示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gitGraph</span><br><span class="line">  commit</span><br><span class="line">  branch develop</span><br><span class="line">  commit</span><br><span class="line">  checkout main</span><br></pre></td></tr></table></figure></li>
<li>Gantt 示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gantt</span><br><span class="line">  title Project</span><br><span class="line">  section Dev</span><br><span class="line">  Task1 :a1, 2023-01-01, 7d</span><br></pre></td></tr></table></figure></li>
<li>说明<br>Mermaid 提供多种图类型，适合文档内快速表达不同视图。  </li>
<li>停顿&#x2F;风险<br>各图类型语法差异大，某些高级属性在嵌入环境（如 GitHub）被限制或禁用。</li>
</ul>
<hr>
<h3 id="labelling、样式与主题"><a href="#labelling、样式与主题" class="headerlink" title="labelling、样式与主题"></a>labelling、样式与主题</h3><ul>
<li>文本与换行<br>使用 <br> 或 \n 在 label 中换行（平台支持差异）。  </li>
<li>自定义样式（classDef &#x2F; class &#x2F; linkStyle）<br>示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDef green fill:#9f6,stroke:#333,stroke-width:2px;</span><br><span class="line">class A green;</span><br><span class="line">linkStyle 0 stroke:#ff3,stroke-width:2px;</span><br></pre></td></tr></table></figure></li>
<li>说明<br>classDef 可定义节点样式并通过 class 应用到节点，linkStyle 控制边样式。全局主题可通过配置或 CSS（在支持的平台）覆盖。  </li>
<li>停顿&#x2F;风险<br>样式 API 随版本演进，建议将样式提取为可复用片段并在目标平台上验证。</li>
</ul>
<hr>
<h3 id="交互、链接与-Click-事件"><a href="#交互、链接与-Click-事件" class="headerlink" title="交互、链接与 Click 事件"></a>交互、链接与 Click 事件</h3><ul>
<li>超链接 &#x2F; 点击事件<br>语法示例  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">A[Node] --&gt; B</span><br><span class="line">click A &quot;https://example.com&quot; &quot;Open example&quot;</span><br></pre></td></tr></table></figure></li>
<li>说明<br>支持为节点&#x2F;边添加外部链接或 JavaScript 回调（在支持的平台）。  </li>
<li>停顿&#x2F;风险<br>点击回调在静态导出（PNG&#x2F;SVG）中失效；在 web 渲染时注意安全与跨域限制。</li>
</ul>
<hr>
<h3 id="调试、性能与兼容性注意"><a href="#调试、性能与兼容性注意" class="headerlink" title="调试、性能与兼容性注意"></a>调试、性能与兼容性注意</h3><ul>
<li>版本兼容性<br>Mermaid 的语法与功能随版本变化频繁，GitHub&#x2F;GitLab&#x2F;VSCode&#x2F;Docs 的内置 Mermaid 版本可能滞后或差异化。  </li>
<li>性能与大图<br>大图或大量样式会使浏览器渲染卡顿，建议分图或使用懒加载。  </li>
<li>可访问性与文本替代<br>导出图像或嵌入时提供文本说明，复杂图在小屏幕上不可读时提供替代视图。  </li>
<li>停顿&#x2F;风险<br>在 CI 或文档生成管道中使用 Mermaid 时锁定 mermaid-cli 或集成工具版本，避免线上渲染不一致。</li>
</ul>
<hr>
<h3 id="常见坑与最佳实践"><a href="#常见坑与最佳实践" class="headerlink" title="常见坑与最佳实践"></a>常见坑与最佳实践</h3><ul>
<li>坑：直接把复杂 PlantUML&#x2F;Graphviz 文件粘入 Mermaid 无法兼容。<br>最佳实践：按图类型重写为 Mermaid 语法或保持原工具链并在文档中嵌入渲染结果。</li>
<li>坑：节点&#x2F;类名含空格或特殊字符导致解析失败。<br>最佳实践：使用短标识符并通过 label 展示可读文本或用引号包裹 label。</li>
<li>坑：不同渲染环境对 classDef、linkStyle、click 的支持不一致。<br>最佳实践：在目标平台上验证并为不支持的场景提供降级样式或纯文本说明。</li>
<li>坑：版本变更导致现有图渲染异常。<br>最佳实践：在项目中锁定 mermaid 版本并在 CI 中固定渲染工具。</li>
</ul>
<hr>
<h3 id="快速示例合集（可直接复制到-Markdown）"><a href="#快速示例合集（可直接复制到-Markdown）" class="headerlink" title="快速示例合集（可直接复制到 Markdown）"></a>快速示例合集（可直接复制到 Markdown）</h3><ul>
<li>流程图<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">  A[Start] --&gt; B&#123;Check&#125;</span><br><span class="line">  B -- yes --&gt; C[OK]</span><br><span class="line">  B -- no  --&gt; D[Fail]</span><br></pre></td></tr></table></figure></li>
<li>时序图<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">  Alice-&gt;&gt;Bob: Hello</span><br><span class="line">  Bob--&gt;&gt;Alice: Hi</span><br></pre></td></tr></table></figure></li>
<li>类图<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">classDiagram</span><br><span class="line">  Class01 &lt;|-- Class02</span><br><span class="line">  Class01 : +int id</span><br><span class="line">  Class02 : +do()</span><br></pre></td></tr></table></figure></li>
<li>ER 图<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">erDiagram</span><br><span class="line">  USER ||--o&#123; ORDER : places</span><br><span class="line">  USER &#123;</span><br><span class="line">    string name</span><br><span class="line">    int id</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
]]></content>
  </entry>
  <entry>
    <title>Ntp同步客户端</title>
    <url>/Ntp%E5%90%8C%E6%AD%A5%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
    <content><![CDATA[<span id="more"></span>
<h3 id="QtNtpClient-类-—-头文件-qt-ntp-client-h"><a href="#QtNtpClient-类-—-头文件-qt-ntp-client-h" class="headerlink" title="QtNtpClient 类 — 头文件 (qt_ntp_client.h)"></a>QtNtpClient 类 — 头文件 (qt_ntp_client.h)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QUdpSocket&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QElapsedTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDateTime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QTimer&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QHostAddress&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QMutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * QtNtpClient</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - 异步通过 QUdpSocket 向 NTP/SNTP 服务器发起请求并解析响应（不修改系统时间）</span></span><br><span class="line"><span class="comment"> * - 维持一个平滑的时钟偏移估计 (seconds)</span></span><br><span class="line"><span class="comment"> * - 提供将单调时钟事件映射到校正后的 UTC 时间的接口</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 使用方法（示例）:</span></span><br><span class="line"><span class="comment"> *   QtNtpClient *c = new QtNtpClient(parent);</span></span><br><span class="line"><span class="comment"> *   connect(c, &amp;QtNtpClient::offsetUpdated, [](double off, double delay)&#123;</span></span><br><span class="line"><span class="comment"> *     qDebug() &lt;&lt; &quot;offset&quot; &lt;&lt; off &lt;&lt; &quot;delay&quot; &lt;&lt; delay;</span></span><br><span class="line"><span class="comment"> *   &#125;);</span></span><br><span class="line"><span class="comment"> *   c-&gt;queryOnce(QHostAddress(&quot;129.6.15.28&quot;)); // time.nist.gov</span></span><br><span class="line"><span class="comment"> *   // 或周期查询：c-&gt;startPeriodic(QHostAddress(&quot;...&quot;), 60000);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">QtNtpClient</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">  Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">QtNtpClient</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">  ~<span class="built_in">QtNtpClient</span>() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 单次查询，timeoutMs 为 UDP 接收超时（ms）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">queryOnce</span><span class="params">(<span class="type">const</span> QHostAddress &amp;server, quint16 port = <span class="number">123</span>, <span class="type">int</span> timeoutMs = <span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开/关 周期查询（周期以毫秒计）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">startPeriodic</span><span class="params">(<span class="type">const</span> QHostAddress &amp;server, quint16 port = <span class="number">123</span>, <span class="type">int</span> periodMs = <span class="number">60000</span>)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">stopPeriodic</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// EWMA 平滑系数 (0,1], 默认 0.2</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setEwmaAlpha</span><span class="params">(<span class="type">double</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回当前估计的偏移（秒），正值表示 server_time - local_time</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">offsetEstimateSeconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回当前估计的往返延迟（秒），最后一次测量值（非平滑）</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">lastDelaySeconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取当前校正后的 UTC 时间（秒，含小数部分）</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">correctedUtcNowSeconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将单调时钟（毫秒）映射为校正后的 UTC 秒。用于以单调计时记录事件时间：</span></span><br><span class="line">  <span class="comment">//   mapped = mapMonotonicMsToCorrectedUtc(monoMs);</span></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">mapMonotonicMsToCorrectedUtc</span><span class="params">(qint64 monotonicMs)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">  <span class="comment">// 平滑后的偏移值与本次测量的往返延迟（seconds）</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">offsetUpdated</span><span class="params">(<span class="type">double</span> offsetSeconds, <span class="type">double</span> delaySeconds)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 查询失败或超时时发出</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">queryFailed</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> slots:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onReadyRead</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onTimeout</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">onPeriodicTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// helpers</span></span><br><span class="line">  <span class="function"><span class="type">static</span> quint32 <span class="title">toNtpSec</span><span class="params">(<span class="type">double</span> unixSecs)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> quint32 <span class="title">toNtpFrac</span><span class="params">(<span class="type">double</span> unixSecs)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">ntpToUnix</span><span class="params">(quint32 sec, quint32 frac)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">double</span> <span class="title">nowWallUtcSeconds</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">  <span class="function">qint64 <span class="title">nowMonoMs</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">processResponse</span><span class="params">(<span class="type">const</span> QByteArray &amp;datagram, <span class="type">double</span> t4_wall, qint64 t4_mono)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">recordMappingPoint</span><span class="params">(<span class="type">double</span> wallUtcSec, qint64 monoMs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  QUdpSocket *m_sock = <span class="literal">nullptr</span>;</span><br><span class="line">  QTimer m_timeoutTimer;</span><br><span class="line">  QTimer m_periodicTimer;</span><br><span class="line">  QHostAddress m_periodicServer;</span><br><span class="line">  quint16 m_periodicPort = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reference mapping between monotonic and wall-clock (established at construction and updated on successful sync)</span></span><br><span class="line">  QElapsedTimer m_monoTimer;</span><br><span class="line">  qint64 m_refMonoMs = <span class="number">0</span>;</span><br><span class="line">  <span class="type">double</span> m_refWallUtcSec = <span class="number">0.0</span>; <span class="comment">// seconds since epoch</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// pending request info</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Pending</span> &#123;</span><br><span class="line">    <span class="type">double</span> t1_wall = <span class="number">0.0</span>; <span class="comment">// originate timestamp in unix seconds</span></span><br><span class="line">    qint64 t1_mono = <span class="number">0</span>;   <span class="comment">// monotonic ms when sent</span></span><br><span class="line">    <span class="type">bool</span> active = <span class="literal">false</span>;</span><br><span class="line">  &#125; m_pending;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// smoothing &amp; stats</span></span><br><span class="line">  <span class="keyword">mutable</span> QMutex m_mutex;</span><br><span class="line">  <span class="type">double</span> m_offsetEwma = <span class="number">0.0</span>;</span><br><span class="line">  <span class="type">double</span> m_ewmaAlpha = <span class="number">0.2</span>;</span><br><span class="line">  <span class="type">double</span> m_lastDelay = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// constants</span></span><br><span class="line">  <span class="type">static</span> <span class="keyword">constexpr</span> quint32 NTP_DELTA = <span class="number">2208988800u</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="QtNtpClient-类-—-实现文件-qt-ntp-client-cpp"><a href="#QtNtpClient-类-—-实现文件-qt-ntp-client-cpp" class="headerlink" title="QtNtpClient 类 — 实现文件 (qt_ntp_client.cpp)"></a>QtNtpClient 类 — 实现文件 (qt_ntp_client.cpp)</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;qt_ntp_client.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDataStream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QtMath&gt;</span></span></span><br><span class="line"></span><br><span class="line">QtNtpClient::<span class="built_in">QtNtpClient</span>(QObject *parent) : <span class="built_in">QObject</span>(parent) &#123;</span><br><span class="line">  m_sock = <span class="keyword">new</span> <span class="built_in">QUdpSocket</span>(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">connect</span>(m_sock, &amp;QUdpSocket::readyRead, <span class="keyword">this</span>, &amp;QtNtpClient::onReadyRead);</span><br><span class="line">  <span class="built_in">connect</span>(&amp;m_timeoutTimer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;QtNtpClient::onTimeout);</span><br><span class="line">  <span class="built_in">connect</span>(&amp;m_periodicTimer, &amp;QTimer::timeout, <span class="keyword">this</span>, &amp;QtNtpClient::onPeriodicTimeout);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始化单调-&gt;墙钟映射</span></span><br><span class="line">  m_monoTimer.<span class="built_in">start</span>();</span><br><span class="line">  m_refMonoMs = m_monoTimer.<span class="built_in">elapsed</span>();</span><br><span class="line">  m_refWallUtcSec = QDateTime::<span class="built_in">currentDateTimeUtc</span>().<span class="built_in">toMSecsSinceEpoch</span>() / <span class="number">1000.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 初始偏移值为0</span></span><br><span class="line">  m_offsetEwma = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QtNtpClient::~<span class="built_in">QtNtpClient</span>() &#123;</span><br><span class="line">  <span class="built_in">stopPeriodic</span>();</span><br><span class="line">  <span class="keyword">if</span> (m_sock) &#123;</span><br><span class="line">    m_sock-&gt;<span class="built_in">close</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::setEwmaAlpha</span><span class="params">(<span class="type">double</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (a &lt;= <span class="number">0.0</span>) a = <span class="number">0.001</span>;</span><br><span class="line">  <span class="keyword">if</span> (a &gt; <span class="number">1.0</span>) a = <span class="number">1.0</span>;</span><br><span class="line">  <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">  m_ewmaAlpha = a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QtNtpClient::offsetEstimateSeconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> m_offsetEwma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QtNtpClient::lastDelaySeconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> m_lastDelay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QtNtpClient::nowWallUtcSeconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用映射以提供更稳定的 wall-clock（基于 monotonic 基准）</span></span><br><span class="line">  qint64 nowMono = m_monoTimer.<span class="built_in">elapsed</span>();</span><br><span class="line">  <span class="type">double</span> deltaSec = <span class="built_in">double</span>(nowMono - m_refMonoMs) / <span class="number">1000.0</span>;</span><br><span class="line">  <span class="keyword">return</span> m_refWallUtcSec + deltaSec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">qint64 <span class="title">QtNtpClient::nowMonoMs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m_monoTimer.<span class="built_in">elapsed</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::queryOnce</span><span class="params">(<span class="type">const</span> QHostAddress &amp;server, quint16 port, <span class="type">int</span> timeoutMs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_sock) <span class="keyword">return</span>;</span><br><span class="line">  <span class="function">QByteArray <span class="title">pkt</span><span class="params">(<span class="number">48</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">  pkt[<span class="number">0</span>] = <span class="built_in">char</span>((<span class="number">0</span> &lt;&lt; <span class="number">6</span>) | (<span class="number">4</span> &lt;&lt; <span class="number">3</span>) | <span class="number">3</span>); <span class="comment">// LI=0 VN=4 Mode=3 (client)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 填 originate timestamp (bytes 24..31)</span></span><br><span class="line">  <span class="type">double</span> t1 = <span class="built_in">nowWallUtcSeconds</span>();</span><br><span class="line">  quint32 sec = <span class="built_in">toNtpSec</span>(t1);</span><br><span class="line">  quint32 frac = <span class="built_in">toNtpFrac</span>(t1);</span><br><span class="line"></span><br><span class="line">  <span class="function">QDataStream <span class="title">ds</span><span class="params">(&amp;pkt, QIODevice::WriteOnly)</span></span>;</span><br><span class="line">  ds.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line">  ds.<span class="built_in">device</span>()-&gt;<span class="built_in">seek</span>(<span class="number">24</span>);</span><br><span class="line">  ds &lt;&lt; sec &lt;&lt; frac;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 记录 pending</span></span><br><span class="line">  m_pending.t1_wall = t1;</span><br><span class="line">  m_pending.t1_mono = <span class="built_in">nowMonoMs</span>();</span><br><span class="line">  m_pending.active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 发送</span></span><br><span class="line">  m_sock-&gt;<span class="built_in">writeDatagram</span>(pkt, server, port);</span><br><span class="line">  m_timeoutTimer.<span class="built_in">start</span>(timeoutMs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::startPeriodic</span><span class="params">(<span class="type">const</span> QHostAddress &amp;server, quint16 port, <span class="type">int</span> periodMs)</span> </span>&#123;</span><br><span class="line">  m_periodicServer = server;</span><br><span class="line">  m_periodicPort = port;</span><br><span class="line">  m_periodicTimer.<span class="built_in">start</span>(periodMs);</span><br><span class="line">  <span class="comment">// 立即触发一次</span></span><br><span class="line">  <span class="built_in">queryOnce</span>(server, port, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::stopPeriodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m_periodicTimer.<span class="built_in">stop</span>();</span><br><span class="line">  m_timeoutTimer.<span class="built_in">stop</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::onPeriodicTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!m_periodicServer.<span class="built_in">isNull</span>()) &#123;</span><br><span class="line">    <span class="built_in">queryOnce</span>(m_periodicServer, m_periodicPort, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::onTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m_timeoutTimer.<span class="built_in">stop</span>();</span><br><span class="line">  m_pending.active = <span class="literal">false</span>;</span><br><span class="line">  <span class="function">emit <span class="title">queryFailed</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::onReadyRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (m_sock-&gt;<span class="built_in">hasPendingDatagrams</span>()) &#123;</span><br><span class="line">    QByteArray datagram;</span><br><span class="line">    datagram.<span class="built_in">resize</span>(<span class="built_in">int</span>(m_sock-&gt;<span class="built_in">pendingDatagramSize</span>()));</span><br><span class="line">    QHostAddress from; quint16 port;</span><br><span class="line">    m_sock-&gt;<span class="built_in">readDatagram</span>(datagram.<span class="built_in">data</span>(), datagram.<span class="built_in">size</span>(), &amp;from, &amp;port);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录接收时刻</span></span><br><span class="line">    qint64 t4_mono = <span class="built_in">nowMonoMs</span>();</span><br><span class="line">    <span class="type">double</span> t4_wall = <span class="built_in">nowWallUtcSeconds</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">processResponse</span>(datagram, t4_wall, t4_mono);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::processResponse</span><span class="params">(<span class="type">const</span> QByteArray &amp;datagram, <span class="type">double</span> t4_wall, qint64 t4_mono)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (datagram.<span class="built_in">size</span>() &lt; <span class="number">48</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">QDataStream <span class="title">ds</span><span class="params">(datagram)</span></span>;</span><br><span class="line">  ds.<span class="built_in">setByteOrder</span>(QDataStream::BigEndian);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取 originate (24..31), recv (32..39), tx (40..47)</span></span><br><span class="line">  ds.<span class="built_in">device</span>()-&gt;<span class="built_in">seek</span>(<span class="number">24</span>);</span><br><span class="line">  quint32 orig_sec = <span class="number">0</span>, orig_frac = <span class="number">0</span>;</span><br><span class="line">  quint32 recv_sec = <span class="number">0</span>, recv_frac = <span class="number">0</span>;</span><br><span class="line">  quint32 tx_sec = <span class="number">0</span>, tx_frac = <span class="number">0</span>;</span><br><span class="line">  ds &gt;&gt; orig_sec &gt;&gt; orig_frac &gt;&gt; recv_sec &gt;&gt; recv_frac &gt;&gt; tx_sec &gt;&gt; tx_frac;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 转为主机字节序并转成 unix 秒</span></span><br><span class="line">  <span class="type">double</span> T1 = <span class="built_in">ntpToUnix</span>(orig_sec, orig_frac);</span><br><span class="line">  <span class="type">double</span> T2 = <span class="built_in">ntpToUnix</span>(recv_sec, recv_frac);</span><br><span class="line">  <span class="type">double</span> T3 = <span class="built_in">ntpToUnix</span>(tx_sec, tx_frac);</span><br><span class="line">  <span class="type">double</span> T4 = t4_wall;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> delay = (T4 - T1) - (T3 - T2);</span><br><span class="line">  <span class="type">double</span> offset = ((T2 - T1) + (T3 - T4)) / <span class="number">2.0</span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 首次初始化偏移（避免初始值 0 对 EWMA 产生大误差）</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">qIsFinite</span>(m_offsetEwma) &amp;&amp; m_offsetEwma == <span class="number">0.0</span>) &#123;</span><br><span class="line">      m_offsetEwma = offset;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      m_offsetEwma = m_ewmaAlpha * offset + (<span class="number">1.0</span> - m_ewmaAlpha) * m_offsetEwma;</span><br><span class="line">    &#125;</span><br><span class="line">    m_lastDelay = delay;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新 monotonic-&gt;wall 映射点（使用接收时刻）</span></span><br><span class="line">  <span class="built_in">recordMappingPoint</span>(T4, t4_mono);</span><br><span class="line"></span><br><span class="line">  m_pending.active = <span class="literal">false</span>;</span><br><span class="line">  m_timeoutTimer.<span class="built_in">stop</span>();</span><br><span class="line">  <span class="function">emit <span class="title">offsetUpdated</span><span class="params">(offsetEstimateSeconds(), lastDelaySeconds())</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QtNtpClient::recordMappingPoint</span><span class="params">(<span class="type">double</span> wallUtcSec, qint64 monoMs)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 重新锚定映射点以减少漂移影响（采用简单的移动平均）</span></span><br><span class="line">  <span class="comment">// 这里我们直接替换参考点为最新测量时刻以便后续映射更精确</span></span><br><span class="line">  <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">  m_refWallUtcSec = wallUtcSec;</span><br><span class="line">  m_refMonoMs = monoMs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QtNtpClient::correctedUtcNowSeconds</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> local = QDateTime::<span class="built_in">currentDateTimeUtc</span>().<span class="built_in">toMSecsSinceEpoch</span>() / <span class="number">1000.0</span>;</span><br><span class="line">  <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> local + m_offsetEwma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QtNtpClient::mapMonotonicMsToCorrectedUtc</span><span class="params">(qint64 monotonicMs)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  <span class="function">QMutexLocker <span class="title">locker</span><span class="params">(&amp;m_mutex)</span></span>;</span><br><span class="line">  <span class="type">double</span> deltaSec = <span class="built_in">double</span>(monotonicMs - m_refMonoMs) / <span class="number">1000.0</span>;</span><br><span class="line">  <span class="type">double</span> wall = m_refWallUtcSec + deltaSec;</span><br><span class="line">  <span class="keyword">return</span> wall + m_offsetEwma;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NTP helpers</span></span><br><span class="line"><span class="function">quint32 <span class="title">QtNtpClient::toNtpSec</span><span class="params">(<span class="type">double</span> unixSecs)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> s = unixSecs + <span class="built_in">double</span>(NTP_DELTA);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">quint32</span>(std::<span class="built_in">floor</span>(s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">quint32 <span class="title">QtNtpClient::toNtpFrac</span><span class="params">(<span class="type">double</span> unixSecs)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> s = unixSecs + <span class="built_in">double</span>(NTP_DELTA);</span><br><span class="line">  <span class="type">double</span> frac = s - std::<span class="built_in">floor</span>(s);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">quint32</span>(frac * <span class="number">0x100000000ULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">QtNtpClient::ntpToUnix</span><span class="params">(quint32 sec, quint32 frac)</span> </span>&#123;</span><br><span class="line">  <span class="type">double</span> s = <span class="built_in">double</span>(sec) - <span class="built_in">double</span>(NTP_DELTA) + <span class="built_in">double</span>(frac) / <span class="built_in">double</span>(<span class="number">0x100000000ULL</span>);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="说明与使用建议"><a href="#说明与使用建议" class="headerlink" title="说明与使用建议"></a>说明与使用建议</h3><ul>
<li><p>该实现:</p>
<ul>
<li>完整以类形式封装，无需改变系统时间，仅在应用层维护偏移估计。</li>
<li>使用 QUdpSocket 非阻塞异步 I&#x2F;O，适合 GUI 或服务程序。</li>
<li>提供周期查询和单次查询接口，并通过信号上报结果或失败。</li>
</ul>
</li>
<li><p>精度与鲁棒性建议:</p>
<ul>
<li>在真实网络中建议多次采样并过滤高延迟样本，再用加权或中位数选取最终偏移。</li>
<li>可以在 processResponse 中收集多次样本然后选最小 delay 的 offset 或用权重 1&#x2F;delay 做加权平均。</li>
<li>对偏移使用更稳健的滤波器（Kalman、滑动中位数或更复杂的时钟跟踪器）能提升长期稳定性。</li>
<li>若需要更高精度（LAN 微秒级），考虑使用 PTP 或硬件时间戳。</li>
</ul>
</li>
<li><p>单调时钟映射:</p>
<ul>
<li>为避免系统时间跳变影响事件计时，建议用 mapMonotonicMsToCorrectedUtc 将单调时钟时间映射到校正墙钟再加偏移。</li>
<li>recordMappingPoint 在成功同步时重新锚定参考点，减少映射误差。</li>
</ul>
</li>
<li><p>权限:</p>
<ul>
<li>本类不会调用 settimeofday 或 adjtime，不需要 root 权限。若需要修改系统时钟，请交由系统服务（chrony&#x2F;ntpd）或谨慎使用特权系统调用。</li>
</ul>
</li>
</ul>
<p>本类可以扩展为：多服务器并行查询、延迟&#x2F;偏移样本缓冲与选择策略、或加入 Kalman 滤波器</p>
]]></content>
  </entry>
</search>
